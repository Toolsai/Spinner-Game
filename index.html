<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Êà∞È¨•ÈôÄËû∫3D - ÊóãËΩâËÉΩÈáèÈ°ØÁ§∫Áâà</title> {/* Changed Title */}
    <style>
        /* Styles remain the same, added spin bar styles */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #282c34; position: fixed; width: 100%; height: 100%; }
        #selection-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #2c3e50, #1a252f); color: #ecf0f1; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; padding: 20px; box-sizing: border-box; overflow-y: auto; }
        #selection-screen h2 { margin-bottom: 40px; font-size: 2.5em; text-shadow: 2px 2px 5px rgba(0,0,0,0.5); color: #e0e0e0; }
        #beyblade-options { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; max-width: 100%; padding: 10px; box-sizing: border-box; }
        .bey-card { position: relative; width: calc(100% - 40px); max-width: 300px; height: 200px; border-radius: 15px; overflow: hidden; cursor: pointer; background-color: #34495e; box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.4); border: 3px solid transparent; transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease; display: flex; flex-direction: column; margin: 10px auto; }
        .bey-card:hover { transform: translateY(-10px) scale(1.03); box-shadow: 8px 12px 20px rgba(0, 0, 0, 0.5); }
        .bey-card .bey-preview { height: 60%; padding: 10px; display: flex; justify-content: center; align-items: center; position: relative; }
         .bey-card .bey-symbol { font-size: 5em; color: rgba(255, 255, 255, 0.2); text-shadow: 2px 2px 5px rgba(0,0,0,0.4); z-index: 2; }
         .bey-card .bey-info { height: 40%; padding: 10px; box-sizing: border-box; background-color: rgba(0, 0, 0, 0.4); color: #ecf0f1; display: flex; flex-direction: column; justify-content: center; position: relative; z-index: 3; }
          .bey-card .bey-name { font-size: 1.2em; margin-bottom: 5px; font-weight: bold; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); }
          .bey-card .bey-stats { font-size: 0.9em; line-height: 1.4; color: #bdc3c7; }
        .bey-card.selected { border-color: #2ecc71; transform: translateY(-5px) scale(1.05); box-shadow: 0 0 25px rgba(46, 204, 113, 0.7); }
        #start-button { margin: 20px; padding: 12px 30px; font-size: 1.2em; cursor: pointer; background: linear-gradient(145deg, #2ecc71, #27ae60); color: white; border: none; border-radius: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); transition: background 0.2s ease, transform 0.1s ease; display: none; }
        #start-button:hover { background: linear-gradient(145deg, #3fe383, #2ebb69); }
        #start-button:active { transform: scale(0.97); }
        #start-button:disabled { background: #7f8c8d; cursor: not-allowed; opacity: 0.6; }
        #game-container { position: fixed; width: 100%; height: 100%; top: 0; left: 0; display: none; cursor: pointer; }
        #game-ui { position: absolute; top: 60px; /* Adjusted top position */ left: 50%; transform: translateX(-50%); color: white; background-color: rgba(44, 62, 80, 0.7); padding: 12px 25px; border-radius: 8px; font-size: 1.6em; z-index: 5; text-shadow: 1px 1px 3px rgba(0,0,0,0.7); display: none; pointer-events: none; text-align: center; }
        #charge-bar-container { position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%); width: 350px; height: 35px; background-color: rgba(0, 0, 0, 0.6); border: 2px solid #95a5a6; border-radius: 18px; z-index: 6; display: none; overflow: hidden; pointer-events: none; }
        #charge-bar-fill { width: 100%; height: 100%; background: linear-gradient(to right, #e74c3c, #f39c12, #2ecc71, #f39c12, #e74c3c); border-radius: 16px; }
        #charge-indicator { position: absolute; top: -2px; bottom: -2px; left: 0%; width: 6px; background-color: rgba(255, 255, 255, 0.9); border-radius: 3px; box-shadow: 0 0 5px rgba(255, 255, 255, 0.7); transform: translateX(-50%); transition: left 0.05s linear; }

        /* --- Spin Bar Styles --- */
        .spin-bar-container { position: absolute; top: 30px; width: 35%; max-width: 400px; height: 35px; background-color: rgba(0, 0, 0, 0.5); border: 3px solid #7f8c8d; border-radius: 18px; z-index: 7; overflow: hidden; display: none; /* Initially hidden */ box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .spin-bar-fill { height: 100%; width: 100%; /* Start full */ border-radius: 11px; transition: width 0.15s linear; /* Smooth transition */ background-color: #e67e22; /* Default fill */ }
        .spin-bar-label { color: white; font-size: 1.2em; text-shadow: 2px 2px 3px black; position: absolute; top: 50%; transform: translateY(-50%); padding: 0 15px; z-index: 8; pointer-events: none; }

        #player-spin-bar-container { left: 20px; }
        #player-spin-bar-label { left: 0; }
        /* Player fill color set in JS */

        #ai-spin-bar-container { right: 20px; }
        #ai-spin-bar-label { right: 0; text-align: right;}
        /* AI fill color set in JS */
        /* --- End Spin Bar Styles --- */

    </style>
</head>
<body>
    <div id="selection-screen"><h2>Make your choice</h2><div id="beyblade-options"></div><button id="start-button" disabled>Start Game</button></div>

    <div id="game-container">
        <!-- Spin Bars -->
        <div id="player-spin-bar-container" class="spin-bar-container">
            <div id="player-spin-bar-fill" class="spin-bar-fill"></div>
            <span id="player-spin-bar-label" class="spin-bar-label">Áé©ÂÆ∂</span>
        </div>
        <div id="ai-spin-bar-container" class="spin-bar-container">
            <div id="ai-spin-bar-fill" class="spin-bar-fill"></div>
             <span id="ai-spin-bar-label" class="spin-bar-label">AI</span>
        </div>
        <!-- End Spin Bars -->

        <div id="charge-bar-container"><div id="charge-bar-fill"></div><div id="charge-indicator"></div></div>
    </div>
    <div id="game-ui">Wait for Start...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- Configuration ---
        const BEYBLADE_TYPES = [
            { id: 'pegasus', name: 'Chat-GPT', symbol: '‚≠ê', color: 0x4488ff, colorHex: '#4488ff', weight: 1.0, initialSpeed: 0.15, stamina: 120 },
             { id: 'l-drago', name: 'Grok', symbol: 'üî•', color: 0xff4444, colorHex: '#ff4444', weight: 1.3, initialSpeed: 0.12, stamina: 110 },
             { id: 'libra', name: 'Gemini', symbol: '‚öñÔ∏è', color: 0x44ff44, colorHex: '#44ff44', weight: 1.1, initialSpeed: 0.11, stamina: 130 }
        ];
        const ARENA_RADIUS = 15; const BEYBLADE_RADIUS = 2; const LAUNCH_DISTANCE = ARENA_RADIUS * 0.65;

        // -- Physics & Collision Parameters --
        const GRAVITY_TOWARDS_CENTER = 0.0300; const FRICTION = 0.0010; const SPIN_FRICTION = 0.0150;
        const BOUNDARY_ENERGY_LOSS = 0.3; const COLLISION_ENERGY_LOSS = 0.25; const INTENSITY_MULTIPLIER = 1.9;
        const TANGENTIAL_KICK_FACTOR = 30; const COLLISION_SPIN_LOSS_FACTOR = 3.0; const MAX_VELOCITY = 0.6;

        // -- Launch Mechanic Parameters --
        const MIN_LAUNCH_POWER = 0.25; const INDICATOR_SPEED = 4.0;

        // --- Spark Particle Configuration ---
        const SPARK_COUNT = 90;         
        const SPARK_LIFESPAN = 0.45;    
        const SPARK_SPEED_MIN = 15.0;   // Ë™øÊï¥ÊúÄÂ∞èÈÄüÂ∫¶
        const SPARK_SPEED_MAX = 35.0;   // Ë™øÊï¥ÊúÄÂ§ßÈÄüÂ∫¶
        const SPARK_BASE_SIZE = 5;      // Ë™øÊï¥Âü∫Á§éÂ§ßÂ∞è
        const SPARK_COLOR = 0xff8c00;   
        const SPARK_POOL_SIZE = 20;
        const SPARK_GRAVITY = -12.0;    // Â¢ûÂä†ÈáçÂäõÊïàÊûú

        // --- Global Variables ---
        let scene, camera, renderer;
        let arenaMesh, rimMesh;
        let playerBeyData = { mesh: null, type: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0, maxStamina: 0 }; // Added maxStamina
        let aiBeyData = { mesh: null, type: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0, maxStamina: 0 }; // Added maxStamina
        let gameState = 'selecting';
        let animationFrameId;
        let selectedPlayerTypeId = null;
        let launchInitiated = false;
        let indicatorPosition = 0; let indicatorDirection = 1; let captureIndicatorPosition = -1;
        let sparkPool = []; let sparkPoolIndex = 0; let sparkGeometry = null;
        let sparkTexture = null;

        // --- Materials Cache ---
        const materialsCache = {};
        function getMaterial(color, options = {}) { const key = `${color}_${JSON.stringify(options)}`; if (!materialsCache[key]) { materialsCache[key] = new THREE.MeshStandardMaterial({ color, ...options }); } return materialsCache[key]; }

        // --- DOM Elements ---
        const selectionScreen = document.getElementById('selection-screen'); const beybladeOptionsContainer = document.getElementById('beyblade-options'); const startButton = document.getElementById('start-button'); const gameContainer = document.getElementById('game-container'); const gameUi = document.getElementById('game-ui'); const chargeBarContainer = document.getElementById('charge-bar-container'); const chargeBarFill = document.getElementById('charge-bar-fill'); const chargeIndicator = document.getElementById('charge-indicator');
        // Spin Bar Elements
        const playerSpinBarContainer = document.getElementById('player-spin-bar-container');
        const playerSpinFill = document.getElementById('player-spin-bar-fill');
        const playerSpinLabel = document.getElementById('player-spin-bar-label');
        const aiSpinBarContainer = document.getElementById('ai-spin-bar-container');
        const aiSpinFill = document.getElementById('ai-spin-bar-fill');
        const aiSpinLabel = document.getElementById('ai-spin-bar-label');

        // --- Clock for Delta Time ---
        const clock = new THREE.Clock();

        // --- Initialization ---
        function init() {
            // ‰øÆÊîπÂ†¥ÊôØËÉåÊôØËâ≤ÁÇ∫Ê∑±Á¥´Ëâ≤
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0014); // Ê∑±Á¥´Ëâ≤ËÉåÊôØ
            scene.fog = new THREE.Fog(scene.background, ARENA_RADIUS * 2.5, ARENA_RADIUS * 5);

            // Ê∑ªÂä†Á∂≤Ê†ºÊïàÊûú
            createGridBackground();
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, ARENA_RADIUS * 1.5, ARENA_RADIUS * 1.1); camera.lookAt(0, 0, 0);
             renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.outputEncoding = THREE.sRGBEncoding; gameContainer.appendChild(renderer.domElement);
             const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); directionalLight.position.set(10, 20, 15); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50; directionalLight.shadow.camera.left = -ARENA_RADIUS * 1.5; directionalLight.shadow.camera.right = ARENA_RADIUS * 1.5; directionalLight.shadow.camera.top = ARENA_RADIUS * 1.5; directionalLight.shadow.camera.bottom = -ARENA_RADIUS * 1.5; scene.add(directionalLight); const fillLight = new THREE.HemisphereLight(0x6060aa, 0x404088, 0.2); scene.add(fillLight);
            createArena();
            initSparkSystem(); // Initialize sparks
            window.addEventListener('resize', onWindowResize, false);
            setupSelectionUI();
            setupLaunchControls();
        }

        function createArena() {
            const geometry = new THREE.CircleGeometry(ARENA_RADIUS, 64); const material = getMaterial(0x505055, { metalness: 0.3, roughness: 0.6, side: THREE.DoubleSide }); arenaMesh = new THREE.Mesh(geometry, material); arenaMesh.rotation.x = -Math.PI / 2; arenaMesh.receiveShadow = true; scene.add(arenaMesh); const rimGeometry = new THREE.RingGeometry(ARENA_RADIUS, ARENA_RADIUS + 0.6, 64); const rimMaterial = getMaterial(0xaaaaaa, { metalness: 0.5, roughness: 0.4, side: THREE.DoubleSide }); rimMesh = new THREE.Mesh(rimGeometry, rimMaterial); rimMesh.rotation.x = -Math.PI / 2; rimMesh.position.y = 0.02; rimMesh.receiveShadow = true; scene.add(rimMesh);
        }

        function initSparkSystem() {
            sparkTexture = createSparkTexture(); // Use the existing radial gradient texture
            sparkGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(SPARK_COUNT * 3); const velocities = new Float32Array(SPARK_COUNT * 3); const startTimes = new Float32Array(SPARK_COUNT); const baseSizes = new Float32Array(SPARK_COUNT);
            sparkGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); sparkGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3)); sparkGeometry.setAttribute('startTime', new THREE.BufferAttribute(startTimes, 1)); sparkGeometry.setAttribute('baseSize', new THREE.BufferAttribute(baseSizes, 1));

            const baseSparkMaterial = new THREE.PointsMaterial({
                size: SPARK_BASE_SIZE, // Use the new larger base size
                color: SPARK_COLOR,    // Use the new orange color
                map: sparkTexture,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false,
                sizeAttenuation: true,
                opacity: 1.0
            });

            for (let i = 0; i < SPARK_POOL_SIZE; i++) {
                const materialClone = baseSparkMaterial.clone();
                const points = new THREE.Points(sparkGeometry, materialClone);
                points.visible = false;
                points.userData = { isActive: false, activationTime: 0 };
                sparkPool.push(points);
                scene.add(points);
            }
        }

        function createSparkTexture() {
             // Keep the existing texture, it provides a good base shape
             const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64; const context = canvas.getContext('2d'); const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32); gradient.addColorStop(0, 'rgba(255, 255, 220, 1)'); gradient.addColorStop(0.1, 'rgba(255, 200, 100, 1)'); gradient.addColorStop(0.4, 'rgba(255, 165, 0, 0.6)'); gradient.addColorStop(1, 'rgba(255, 140, 0, 0)'); context.fillStyle = gradient; context.fillRect(0, 0, 64, 64); const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; return texture;
        }

        function setupSelectionUI() {
             beybladeOptionsContainer.innerHTML = ''; if (!beybladeOptionsContainer) { console.error("Element with ID 'beyblade-options' not found!"); return; } BEYBLADE_TYPES.forEach(type => { const card = document.createElement('div'); card.classList.add('bey-card'); card.dataset.beyId = type.id; const previewArea = document.createElement('div'); previewArea.classList.add('bey-preview'); previewArea.style.background = `radial-gradient(ellipse at top, ${lightenColor(type.colorHex, 30)}, ${type.colorHex} 70%)`; const symbolSpan = document.createElement('span'); symbolSpan.classList.add('bey-symbol'); symbolSpan.textContent = type.symbol || 'üåÄ'; previewArea.appendChild(symbolSpan); card.appendChild(previewArea); const infoDiv = document.createElement('div'); infoDiv.classList.add('bey-info'); infoDiv.innerHTML = `<div class="bey-name">${type.name}</div><div class="bey-stats">È´îÈáç: ${type.weight.toFixed(1)} | ÈÄüÂ∫¶: ${type.initialSpeed.toFixed(2)} | ËÄêÂäõ: ${type.stamina}</div>`; card.appendChild(infoDiv); card.addEventListener('click', () => { document.querySelectorAll('.bey-card').forEach(c => c.classList.remove('selected')); card.classList.add('selected'); selectedPlayerTypeId = type.id; if(startButton) { startButton.disabled = false; startButton.style.display = 'inline-block'; } }); beybladeOptionsContainer.appendChild(card); }); if(startButton) startButton.addEventListener('click', startGame);
        }

        function lightenColor(hex, percent) {
              hex = hex.replace(/^#/, ''); const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); const newR = Math.min(255, r + Math.floor(255 * (percent / 100))); const newG = Math.min(255, g + Math.floor(255 * (percent / 100))); const newB = Math.min(255, b + Math.floor(255 * (percent / 100))); return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }

        function startGame() {
             if (!selectedPlayerTypeId) return;
             gameState = 'preparing';
             launchInitiated = false;
             captureIndicatorPosition = -1;
             indicatorPosition = Math.random();
             indicatorDirection = Math.random() < 0.5 ? 1 : -1;

             selectionScreen.style.display = 'none';
             gameContainer.style.display = 'block';
             gameUi.style.display = 'block'; // Show center UI first
             gameUi.textContent = "Ê∫ñÂÇô...";

             playerBeyData.type = BEYBLADE_TYPES.find(b => b.id === selectedPlayerTypeId);
             const availableAiTypes = BEYBLADE_TYPES.filter(b => b.id !== selectedPlayerTypeId);
             aiBeyData.type = availableAiTypes[Math.floor(Math.random() * availableAiTypes.length)];

             // Store max stamina for bars
             playerBeyData.maxStamina = playerBeyData.type.stamina;
             aiBeyData.maxStamina = aiBeyData.type.stamina;

             resetBattle(); // Includes hiding spin bars initially
             setupBattle();

             // Show Spin Bars and set initial state/colors
             if (playerSpinBarContainer) playerSpinBarContainer.style.display = 'block';
             if (aiSpinBarContainer) aiSpinBarContainer.style.display = 'block';
             if (playerSpinFill) {
                 playerSpinFill.style.width = '100%';
                 playerSpinFill.style.backgroundColor = playerBeyData.type.colorHex; // Set color
                 playerSpinLabel.textContent = playerBeyData.type.name; // Set Label
             }
             if (aiSpinFill) {
                 aiSpinFill.style.width = '100%';
                 aiSpinFill.style.backgroundColor = aiBeyData.type.colorHex; // Set color
                 aiSpinLabel.textContent = aiBeyData.type.name; // Set Label
             }


             setTimeout(() => {
                 gameState = 'launching';
                 if(chargeBarContainer) chargeBarContainer.style.display = 'block';
                 if(chargeIndicator) chargeIndicator.style.left = `${indicatorPosition * 100}%`;
                 gameUi.textContent = "ÈªûÊìäËìÑÂäõ!";
                 if (!animationFrameId) {
                     animate();
                 }
             }, 500);
        }

        function setupLaunchControls() {
              if(gameContainer) gameContainer.addEventListener('pointerdown', captureLaunchTiming);
        }

        function captureLaunchTiming(event) {
             if (gameState === 'launching' && !launchInitiated) { event.preventDefault(); captureIndicatorPosition = indicatorPosition; initiateLaunch(); }
        }

        function initiateLaunch() {
              if (launchInitiated || captureIndicatorPosition < 0) return;
              launchInitiated = true;
              if(chargeBarContainer) chargeBarContainer.style.display = 'none'; // Hide charge bar

              const deviation = Math.abs(captureIndicatorPosition - 0.5);
              const timedPower = 1.0 - deviation * 2; // 0 to 1, 1 is perfect timing

              // Calculate initial angular velocity based on timing and base stamina
              const launchPowerFactor = MIN_LAUNCH_POWER + timedPower * (1.0 - MIN_LAUNCH_POWER);
              playerBeyData.angularVelocity = playerBeyData.maxStamina * launchPowerFactor;

              // AI launch (random power)
              const aiLaunchPowerFactor = MIN_LAUNCH_POWER + Math.random() * (1.0 - MIN_LAUNCH_POWER);
              aiBeyData.angularVelocity = aiBeyData.maxStamina * aiLaunchPowerFactor;

              // Set initial linear velocities
              playerBeyData.velocity.set(LAUNCH_DISTANCE * 0.8, 0, (Math.random() - 0.5) * LAUNCH_DISTANCE * 0.8).normalize().multiplyScalar(playerBeyData.type.initialSpeed * (0.8 + launchPowerFactor * 0.4));
              aiBeyData.velocity.set(-LAUNCH_DISTANCE * 0.8, 0, (Math.random() - 0.5) * LAUNCH_DISTANCE * 0.8).normalize().multiplyScalar(aiBeyData.type.initialSpeed * (0.8 + aiLaunchPowerFactor * 0.4));

              gameUi.textContent = "Êà∞È¨•ÈñãÂßã!";
              setTimeout(() => { if (gameState === 'launching') gameState = 'fighting'; }, 100);
        }

        function resetBattle() {
             if (playerBeyData.mesh) scene.remove(playerBeyData.mesh);
             if (aiBeyData.mesh) scene.remove(aiBeyData.mesh);
             // Reset bey data, keeping type and maxStamina potentially
             playerBeyData = { ...playerBeyData, mesh: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0 };
             aiBeyData = { ...aiBeyData, mesh: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0 };

             // Reset sparks
             sparkPool.forEach(points => {
                 if (points.userData.isActive) {
                     points.visible = false;
                     points.userData.isActive = false;
                     points.material.opacity = 1.0;
                     points.material.size = SPARK_BASE_SIZE;
                 }
             });
             sparkPoolIndex = 0;

             // Hide Spin Bars
             if (playerSpinBarContainer) playerSpinBarContainer.style.display = 'none';
             if (aiSpinBarContainer) aiSpinBarContainer.style.display = 'none';
        }

        function createBeybladeMesh(beyType) {
            // ... (createBeybladeMesh function remains unchanged from previous version) ...
            const group = new THREE.Group();
            const radius = BEYBLADE_RADIUS;
            const mainHeight = radius * 0.6;
            const detailHeight = radius * 0.4;
            const mainMat = getMaterial(beyType.color, { metalness: 0.5, roughness: 0.4 });
            const metalMat = getMaterial(0xcccccc, { metalness: 0.8, roughness: 0.3 });
            const darkMetalMat = getMaterial(0x555555, { metalness: 0.7, roughness: 0.4 });
            const accentMat = getMaterial(0xffff00, { metalness: 0.6, roughness: 0.4 });
            let lowestY = 0;

            switch (beyType.id) {
                case 'pegasus': {
                    const bodyGeo = new THREE.CylinderGeometry(radius * 0.8, radius * 0.5, mainHeight, 16);
                    const bodyMesh = new THREE.Mesh(bodyGeo, mainMat);
                    bodyMesh.position.y = detailHeight + mainHeight / 2;
                    bodyMesh.castShadow = true;
                    group.add(bodyMesh);

                    const ringGeo = new THREE.TorusGeometry(radius * 0.9, radius * 0.15, 8, 32);
                    const ringMesh = new THREE.Mesh(ringGeo, metalMat);
                    ringMesh.rotation.x = Math.PI / 2;
                    ringMesh.position.y = detailHeight * 0.8;
                    ringMesh.castShadow = true;
                    group.add(ringMesh);

                    const baseGeo = new THREE.ConeGeometry(radius * 0.6, detailHeight, 16);
                    const baseMesh = new THREE.Mesh(baseGeo, metalMat);
                    baseMesh.position.y = detailHeight / 2;
                    baseMesh.castShadow = true;
                    group.add(baseMesh);
                    lowestY = 0; // Base tip is at y=0
                    break;
                }
                case 'l-drago': {
                    const bodyGeo = new THREE.ConeGeometry(radius * 0.7, mainHeight * 1.2, 16);
                    const bodyMesh = new THREE.Mesh(bodyGeo, mainMat);
                    bodyMesh.position.y = detailHeight + mainHeight * 0.6;
                    bodyMesh.castShadow = true;
                    group.add(bodyMesh);

                    const wheelGeo = new THREE.CylinderGeometry(radius * 1.0, radius * 0.9, detailHeight * 0.8, 16);
                    const wheelMesh = new THREE.Mesh(wheelGeo, darkMetalMat);
                    wheelMesh.position.y = detailHeight * 0.6;
                    wheelMesh.castShadow = true;
                    group.add(wheelMesh);

                    const baseGeo = new THREE.CylinderGeometry(radius * 0.4, radius * 0.2, detailHeight * 0.4, 16);
                    const baseMesh = new THREE.Mesh(baseGeo, darkMetalMat);
                    baseMesh.position.y = detailHeight * 0.2; // Lowest point y = 0
                    baseMesh.castShadow = true;
                    group.add(baseMesh);
                    lowestY = 0;
                    break;
                }
                case 'libra':
                default: {
                    const bodyGeo = new THREE.CylinderGeometry(radius * 0.95, radius * 0.85, mainHeight * 0.6, 24);
                    const bodyMesh = new THREE.Mesh(bodyGeo, mainMat);
                    bodyMesh.position.y = detailHeight + (mainHeight * 0.6) / 2;
                    bodyMesh.castShadow = true;
                    group.add(bodyMesh);

                    const ringGeo = new THREE.TorusGeometry(radius * 0.8, radius * 0.18, 8, 32);
                    const ringMesh = new THREE.Mesh(ringGeo, metalMat);
                    ringMesh.rotation.x = Math.PI / 2;
                    ringMesh.position.y = detailHeight * 0.7;
                    ringMesh.castShadow = true;
                    group.add(ringMesh);

                    const baseTopGeo = new THREE.CylinderGeometry(radius * 0.6, radius * 0.7, detailHeight * 0.4, 16);
                    const baseTopMesh = new THREE.Mesh(baseTopGeo, accentMat);
                    baseTopMesh.position.y = detailHeight * 0.6;
                    baseTopMesh.castShadow = true;
                    group.add(baseTopMesh);

                    const baseBottomGeo = new THREE.CylinderGeometry(radius * 0.7, radius * 0.5, detailHeight * 0.4, 16);
                    const baseBottomMesh = new THREE.Mesh(baseBottomGeo, accentMat);
                    baseBottomMesh.position.y = detailHeight * 0.2; // Lowest point y = 0
                    baseBottomMesh.castShadow = true;
                    group.add(baseBottomMesh);
                    lowestY = 0;
                    break;
                }
            }
            group.position.y = -lowestY;
            const meshBaseOffset = -lowestY;
            return { mesh: group, baseOffset: meshBaseOffset };
        }

        function setupBattle() {
            const playerResult = createBeybladeMesh(playerBeyData.type);
            playerBeyData.mesh = playerResult.mesh;
            playerBeyData.baseOffset = playerResult.baseOffset;
            playerBeyData.mesh.position.set(-LAUNCH_DISTANCE, playerBeyData.baseOffset, (Math.random() - 0.5) * 4);
            scene.add(playerBeyData.mesh);

            const aiResult = createBeybladeMesh(aiBeyData.type);
            aiBeyData.mesh = aiResult.mesh;
            aiBeyData.baseOffset = aiResult.baseOffset;
            aiBeyData.mesh.position.set(LAUNCH_DISTANCE, aiBeyData.baseOffset, (Math.random() - 0.5) * 4);
            scene.add(aiBeyData.mesh);
        }

        function triggerSparks(position, intensity) {
            const points = sparkPool[sparkPoolIndex];
            if (!points) return;
            
            const geometry = points.geometry;
            const attributes = geometry.attributes;
            if (!attributes.velocity || !attributes.startTime || !attributes.position || !attributes.baseSize) {
                console.error("Spark geometry attributes missing!");
                return;
            }
            
            const velocities = attributes.velocity.array;
            const startTimes = attributes.startTime.array;
            const positions = attributes.position.array;
            const baseSizes = attributes.baseSize.array;
            
            points.position.copy(position);
            const currentTime = clock.elapsedTime;
            
            // Ë™øÊï¥Âº∑Â∫¶Ë®àÁÆó
            const intensityFactor = Math.min(1, Math.sqrt(intensity / 20));
            const speedRange = SPARK_SPEED_MAX - SPARK_SPEED_MIN;
            
            for (let i = 0; i < SPARK_COUNT; i++) {
                const i3 = i * 3;
                
                // ÁîüÊàêÊõ¥Èö®Ê©üÁöÑÊñπÂêë
                const angle = Math.random() * Math.PI * 2;
                const heightFactor = Math.random() * 2 - 1; // -1 Âà∞ 1
                const radius = Math.random(); // 0 Âà∞ 1
                
                // Ë®àÁÆóÊñπÂêëÂêëÈáè
                const dirX = Math.cos(angle) * radius;
                const dirY = Math.abs(heightFactor) + 0.2; // Á¢∫‰øùÊúâÂêë‰∏äÁöÑË∂®Âã¢
                const dirZ = Math.sin(angle) * radius;
                
                // Ê®ôÊ∫ñÂåñÊñπÂêëÂêëÈáè
                const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
                
                // Ë®àÁÆóÈÄüÂ∫¶
                const speed = SPARK_SPEED_MIN + Math.random() * speedRange * intensityFactor;
                
                // Ë®≠ÁΩÆÈÄüÂ∫¶
                velocities[i3 + 0] = (dirX / length) * speed * (1 + Math.random() * 0.5);
                velocities[i3 + 1] = (dirY / length) * speed * (1 + Math.random() * 0.5);
                velocities[i3 + 2] = (dirZ / length) * speed * (1 + Math.random() * 0.5);
                
                // ÈáçÁΩÆ‰ΩçÁΩÆ
                positions[i3 + 0] = 0;
                positions[i3 + 1] = 0;
                positions[i3 + 2] = 0;
                
                startTimes[i] = currentTime;
                
                // Èö®Ê©üÁ≤íÂ≠êÂ§ßÂ∞è
                baseSizes[i] = SPARK_BASE_SIZE * (0.5 + Math.random());
            }
            
            // Êõ¥Êñ∞ÊâÄÊúâÂ±¨ÊÄß
            attributes.position.needsUpdate = true;
            attributes.velocity.needsUpdate = true;
            attributes.startTime.needsUpdate = true;
            attributes.baseSize.needsUpdate = true;
            
            points.material.opacity = 1.0;
            points.visible = true;
            points.userData.isActive = true;
            points.userData.activationTime = currentTime;
            
            sparkPoolIndex = (sparkPoolIndex + 1) % SPARK_POOL_SIZE;
        }

        // --- Game Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const currentTime = clock.elapsedTime;

            // --- Indicator Movement ---
            if (gameState === 'launching' && !launchInitiated) {
                indicatorPosition += indicatorDirection * INDICATOR_SPEED * delta;
                if (indicatorPosition >= 1.0) { indicatorPosition = 1.0; indicatorDirection = -1; }
                else if (indicatorPosition <= 0.0) { indicatorPosition = 0.0; indicatorDirection = 1; }
                if (chargeIndicator) { chargeIndicator.style.left = `${indicatorPosition * 100}%`; }
            }

            // --- Main Game Logic ---
            if (gameState === 'fighting') {
                // Update Physics
                updatePhysics(playerBeyData, delta);
                updatePhysics(aiBeyData, delta);
                // Handle Collisions
                handleCollisions(delta);
                // Check Win Conditions
                checkWinConditions();

                // --- Update Spin Bars ---
                // Calculate percentage based on current angular velocity relative to max stamina
                const playerSpinPercent = Math.max(0, Math.min(100, (playerBeyData.angularVelocity / playerBeyData.maxStamina) * 100));
                const aiSpinPercent = Math.max(0, Math.min(100, (aiBeyData.angularVelocity / aiBeyData.maxStamina) * 100));

                // Update the width of the fill divs
                if (playerSpinFill) playerSpinFill.style.width = playerSpinPercent + '%';
                if (aiSpinFill) aiSpinFill.style.width = aiSpinPercent + '%';
                // --- End Spin Bar Update ---
            }

            // --- Spark Update ---
            sparkPool.forEach(points => {
                if (points.userData.isActive) {
                    const activationTime = points.userData.activationTime;
                    const elapsedTime = currentTime - activationTime;
                    const lifeRatio = Math.min(1.0, elapsedTime / SPARK_LIFESPAN);

                    if (lifeRatio >= 1.0) {
                        points.visible = false; 
                        points.userData.isActive = false;
                    } else {
                        points.material.opacity = Math.pow(1.0 - lifeRatio, 1.5);
                        // Adjust size over lifetime - shrink effect
                        points.material.size = SPARK_BASE_SIZE * (1.0 - lifeRatio * 0.8);

                        const geometry = points.geometry; 
                        const attributes = geometry.attributes;
                        const positions = attributes.position.array; 
                        const velocities = attributes.velocity.array; 
                        const startTimes = attributes.startTime.array;
                        let needsPosUpdate = false;
                        
                        for (let i = 0; i < SPARK_COUNT; i++) {
                            if (startTimes[i] === activationTime) {
                                const i3 = i * 3;
                                const particleElapsedTime = currentTime - startTimes[i];
                                
                                // Êõ¥Êñ∞‰ΩçÁΩÆË®àÁÆóÔºåÂä†ÂÖ•Êõ¥Â§öÈö®Ê©üÊÄß
                                positions[i3 + 0] = velocities[i3 + 0] * particleElapsedTime;
                                positions[i3 + 1] = velocities[i3 + 1] * particleElapsedTime + 
                                                  0.5 * SPARK_GRAVITY * particleElapsedTime * particleElapsedTime;
                                positions[i3 + 2] = velocities[i3 + 2] * particleElapsedTime;
                                
                                needsPosUpdate = true;
                            }
                        }
                        if(needsPosUpdate) { 
                            attributes.position.needsUpdate = true; 
                        }
                    }
                }
            });
            // --- End Spark Update ---

            renderer.render(scene, camera);
        }

        // --- Physics & Logic ---
        function updatePhysics(beyData, delta) {
            const groundY = beyData.baseOffset;
            if (!beyData.mesh || beyData.isOut || beyData.angularVelocity <= 0) {
                if (beyData.angularVelocity <= 0 && !beyData.isOut && beyData.mesh) {
                    beyData.velocity.set(0, 0, 0);
                    if (beyData.mesh.position.y !== groundY) beyData.mesh.position.y = groundY;
                }
                return;
            }

            const mesh = beyData.mesh;
            const velocity = beyData.velocity;
            const type = beyData.type;
            const frictionFactor = Math.pow(1.0 - FRICTION, delta * 60);
            velocity.multiplyScalar(frictionFactor);

            const spinDrainMultiplier = Math.max(0.6, (2.2 - type.stamina / 100));
            beyData.angularVelocity -= SPIN_FRICTION * spinDrainMultiplier * delta * 60;
            beyData.angularVelocity = Math.max(0, beyData.angularVelocity);

            // ‰øÆÊîπÈáçÂäõÂΩ±ÈüøÔºöÂ¢ûÂä†Èö®Ê©üÊÄßÂíåÊ≥¢Âãï
            if (GRAVITY_TOWARDS_CENTER > 0) {
                const centerPull = mesh.position.clone().setY(0).negate();
                const distFromCenter = centerPull.length();
                
                // Ê∑ªÂä†Èö®Ê©üÂÅèÁßªÂêëÈáè
                const randomAngle = Math.random() * Math.PI * 2;
                const randomOffset = new THREE.Vector3(
                    Math.cos(randomAngle),
                    0,
                    Math.sin(randomAngle)
                );
                
                // Ê†πÊìöË∑ùÈõ¢‰∏≠ÂøÉÁöÑÈÅ†ËøëË™øÊï¥Èö®Ê©üÊÄß
                const centerInfluence = Math.min(1.0, distFromCenter / (ARENA_RADIUS * 0.8));
                const randomInfluence = 1 - centerInfluence;
                
                // Âêà‰Ωµ‰∏≠ÂøÉÂºïÂäõÂíåÈö®Ê©üÊñπÂêë
                centerPull.normalize();
                const finalDirection = centerPull.multiplyScalar(centerInfluence)
                    .add(randomOffset.multiplyScalar(randomInfluence))
                    .normalize();
                
                // ÊáâÁî®ÂäõÂ∫¶ÔºåÂä†ÂÖ•‰∏Ä‰∫õÊ≥¢Âãï
                const pullStrength = GRAVITY_TOWARDS_CENTER * (0.8 + Math.random() * 0.4);
                velocity.add(finalDirection.multiplyScalar(pullStrength * delta * 60 / type.weight));
            }

            mesh.position.addScaledVector(velocity, delta * 60);
            mesh.rotation.y += beyData.angularVelocity * 0.1 * delta * 60;

            // ÈÇäÁïåÁ¢∞ÊíûËôïÁêÜ
            const distanceFromCenter = mesh.position.clone().setY(0).length();
            if (distanceFromCenter > ARENA_RADIUS - BEYBLADE_RADIUS) {
                const normal = mesh.position.clone().setY(0).normalize().negate();
                const velocityBeforeBounce = velocity.clone();

                // Â¢ûÂä†Á¢∞ÊíûÂæåÁöÑÈö®Ê©üÂÅèËΩâ
                const deflectionAngle = (Math.random() - 0.5) * Math.PI * 0.6; // ÊúÄÂ§ß ¬±90Â∫¶
                normal.applyAxisAngle(new THREE.Vector3(0, 1, 0), deflectionAngle);

                velocity.reflect(normal);
                
                // Èö®Ê©üË™øÊï¥ÂèçÂΩàËÉΩÈáèÊêçÂ§±
                const energyLoss = BOUNDARY_ENERGY_LOSS * (0.8 + Math.random() * 0.4);
                velocity.multiplyScalar(1.0 - energyLoss);

                const sparkPosition = mesh.position.clone().setY(0).setLength(ARENA_RADIUS - BEYBLADE_RADIUS * 0.5);
                sparkPosition.y = beyData.baseOffset + BEYBLADE_RADIUS * 0.3;
                const impactSpeed = velocityBeforeBounce.dot(normal.clone().negate());
                const sparkIntensity = Math.abs(impactSpeed) * 35 + 10;
                triggerSparks(sparkPosition, sparkIntensity);

                // ‰øÆÊ≠£‰ΩçÁΩÆÊôÇÂä†ÂÖ•ËºïÂæÆÈö®Ê©üÂÅèÁßª
                const correctionDir = mesh.position.clone().setY(0).normalize();
                const correctedRadiusPos = (ARENA_RADIUS - BEYBLADE_RADIUS - 0.01) * (0.99 + Math.random() * 0.02);
                mesh.position.x = correctionDir.x * correctedRadiusPos;
                mesh.position.z = correctionDir.z * correctedRadiusPos;

                if (velocity.dot(correctionDir) > 0) {
                    velocity.projectOnVector(normal);
                }
            }

            mesh.position.y = groundY;
        }

        function handleCollisions(delta) {
            // ... (handleCollisions function remains largely unchanged, triggers sparks from center) ...
            if (!playerBeyData.mesh || !aiBeyData.mesh || playerBeyData.isOut || aiBeyData.isOut || gameState !== 'fighting') return; const playerGroundY = playerBeyData.baseOffset; const aiGroundY = aiBeyData.baseOffset; const pos1 = playerBeyData.mesh.position; const pos2 = aiBeyData.mesh.position; const pos1_xz = new THREE.Vector2(pos1.x, pos1.z); const pos2_xz = new THREE.Vector2(pos2.x, pos2.z); const distSq = pos1_xz.distanceToSquared(pos2_xz); const combinedRadius = BEYBLADE_RADIUS * 2; if (distSq < combinedRadius * combinedRadius && distSq > 0.0001) { const v1 = playerBeyData.velocity; const v2 = aiBeyData.velocity; const m1 = playerBeyData.type.weight; const m2 = aiBeyData.type.weight; const collisionNormal = pos1.clone().sub(pos2).setY(0).normalize(); const relativeVelocity = v1.clone().sub(v2); const velAlongNormal = relativeVelocity.dot(collisionNormal); if (velAlongNormal > 0) return; const restitution = 1.0 - COLLISION_ENERGY_LOSS; let j = -(1 + restitution) * velAlongNormal; j /= (1 / m1) + (1 / m2); j *= INTENSITY_MULTIPLIER; const collisionIntensity = Math.abs(j) * 1.0 + 5; // Adjusted intensity calculation
                const sparkPos1 = pos1.clone(); sparkPos1.y += BEYBLADE_RADIUS * 0.2; triggerSparks(sparkPos1, collisionIntensity); const sparkPos2 = pos2.clone(); sparkPos2.y += BEYBLADE_RADIUS * 0.2; triggerSparks(sparkPos2, collisionIntensity); if (TANGENTIAL_KICK_FACTOR > 0) {
                    let tangent = new THREE.Vector3(-collisionNormal.z, 0, collisionNormal.x).normalize();
                    
                    const spinDiff = playerBeyData.angularVelocity - aiBeyData.angularVelocity;
                    if (spinDiff > 0) {
                        tangent.multiplyScalar(1);
                    } else {
                        tangent.multiplyScalar(-1);
                    }
                    
                    const randomAngle = (Math.random() - 0.5) * Math.PI * 0.5;
                    tangent.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle);
                    
                    const spinFactor = Math.abs(spinDiff) / Math.max(playerBeyData.maxStamina, aiBeyData.maxStamina);
                    const tangentialImpulseMagnitude = Math.abs(j) * TANGENTIAL_KICK_FACTOR * (1 + spinFactor);
                    
                    const tangentialImpulse = tangent.multiplyScalar(tangentialImpulseMagnitude);
                    
                    v1.add(tangentialImpulse.clone().multiplyScalar(1 / m1));
                    v2.sub(tangentialImpulse.clone().multiplyScalar(1 / m2));
                } if (COLLISION_SPIN_LOSS_FACTOR > 0) { const spinLossMagnitude = Math.abs(j) * COLLISION_SPIN_LOSS_FACTOR; playerBeyData.angularVelocity = Math.max(0, playerBeyData.angularVelocity - spinLossMagnitude / m1); aiBeyData.angularVelocity = Math.max(0, aiBeyData.angularVelocity - spinLossMagnitude / m2); } const impulse = collisionNormal.clone().multiplyScalar(j); v1.add(impulse.clone().multiplyScalar(1 / m1)); v2.sub(impulse.clone().multiplyScalar(1 / m2)); if (v1.length() > MAX_VELOCITY) v1.setLength(MAX_VELOCITY); if (v2.length() > MAX_VELOCITY) v2.setLength(MAX_VELOCITY); const overlap = combinedRadius - Math.sqrt(distSq); if (overlap > 0) { const separationNormal = pos1.clone().sub(pos2).setY(0).normalize(); const correctionScale = Math.max(0.51, Math.min(0.8, overlap * 0.5)); const correction = separationNormal.multiplyScalar(overlap * correctionScale); pos1.add(correction); pos2.sub(correction); pos1.y = playerGroundY; pos2.y = aiGroundY; } }
        }

        function checkWinConditions() {
            // ... (checkWinConditions remains unchanged) ...
            let winner = null; let loser = null; let reason = ""; if (playerBeyData.isOut && !aiBeyData.isOut) { winner = aiBeyData.type.name; loser = playerBeyData.type.name; reason = "Ë¢´ÊâìÂá∫Áïå"; } else if (aiBeyData.isOut && !playerBeyData.isOut) { winner = playerBeyData.type.name; loser = aiBeyData.type.name; reason = "Ë¢´ÊâìÂá∫Áïå"; } const playerSpinning = playerBeyData.angularVelocity > 0 && !playerBeyData.isOut; const aiSpinning = aiBeyData.angularVelocity > 0 && !aiBeyData.isOut; if (!winner) { if (!playerSpinning && aiSpinning) { winner = aiBeyData.type.name; loser = playerBeyData.type.name; reason = "ÂÅúÊ≠¢ÊóãËΩâ"; } else if (!aiSpinning && playerSpinning) { winner = playerBeyData.type.name; loser = aiBeyData.type.name; reason = "ÂÅúÊ≠¢ÊóãËΩâ"; } else if (!playerSpinning && !aiSpinning && !playerBeyData.isOut && !aiBeyData.isOut) { winner = "Âπ≥Êâã"; reason = "ÈõôÊñπÂÅúÊ≠¢ÊóãËΩâ"; } } if (playerBeyData.isOut && aiBeyData.isOut) { winner = "Âπ≥Êâã"; reason = "ÈõôÊñπÈÉΩË¢´ÊâìÂá∫Áïå"; } if (winner && (gameState === 'fighting' || gameState === 'launching')) { endGame(winner, loser, reason); }
        }

        function endGame(winner, loser, reason) {
             if (gameState === 'gameOver') return;
             gameState = 'gameOver';
             if(chargeBarContainer) chargeBarContainer.style.display = 'none';

             let message = "";
             if (winner === "Âπ≥Êâã") {
                 message = `Âπ≥Êâã! (${reason})`;
             } else {
                 if (winner === playerBeyData.type.name) {
                     message = `ÊÅ≠Âñú ${playerBeyData.type.name} Áç≤Âãù! (AI ${loser} ${reason})`;
                 } else {
                     message = `‰Ω†Ëº∏‰∫Ü! AI ${aiBeyData.type.name} Áç≤Âãù! (${playerBeyData.type.name} ${reason})`;
                 }
             }
             gameUi.textContent = message;
             gameUi.style.display = 'block'; // Show end message

             // Keep spin bars visible during end message display
             // Hide them in the reset timeout

             setTimeout(() => {
                 if (animationFrameId) {
                     cancelAnimationFrame(animationFrameId);
                     animationFrameId = null;
                 }
                 selectedPlayerTypeId = null;
                 document.querySelectorAll('.bey-card').forEach(c => c.classList.remove('selected'));
                 if(startButton) { startButton.disabled = true; startButton.style.display = 'none'; }
                 selectionScreen.style.display = 'flex';
                 gameContainer.style.display = 'none';
                 gameUi.style.display = 'none';
                 // Hiding spin bars is now done in resetBattle which is called below
                 resetBattle(); // Reset meshes, data, and hide spin bars
             }, 4000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start ---
        init();

        // Ê∑ªÂä†Êñ∞ÁöÑÁ∂≤Ê†ºËÉåÊôØÂâµÂª∫ÂáΩÊï∏
        function createGridBackground() {
            // ÂâµÂª∫Á∂≤Ê†ºÊùêË≥™
            const gridMaterial = new THREE.LineBasicMaterial({
                color: 0xff00ff, // Á≤âÁ¥´Ëâ≤
                transparent: true,
                opacity: 0.3
            });

            // ÂâµÂª∫ËóçËâ≤Á∂≤Ê†ºÊùêË≥™
            const blueGridMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffff, // ÈùíËóçËâ≤
                transparent: true,
                opacity: 0.3
            });

            // ÂâµÂª∫Á∂≤Ê†ºÁ∑ö
            const gridSize = ARENA_RADIUS * 4;
            const gridDivisions = 20;
            const gridStep = gridSize / gridDivisions;

            // ÂâµÂª∫Â∑¶ÂÅ¥Á∂≤Ê†º
            const leftGrid = new THREE.Group();
            for (let i = -gridDivisions; i <= gridDivisions; i++) {
                const lineGeometry = new THREE.BufferGeometry();
                const points = [];
                
                // Ê∞¥Âπ≥Á∑ö
                points.push(new THREE.Vector3(-gridSize, gridSize * 0.5, i * gridStep));
                points.push(new THREE.Vector3(0, 0, i * gridStep));
                
                lineGeometry.setFromPoints(points);
                const line = new THREE.Line(lineGeometry, gridMaterial);
                leftGrid.add(line);
            }
            
            // ÂûÇÁõ¥‰∫§ÂèâÁ∑ö
            for (let i = 0; i <= gridDivisions; i++) {
                const lineGeometry = new THREE.BufferGeometry();
                const points = [];
                
                const x = -gridSize + (i * gridStep);
                points.push(new THREE.Vector3(x, gridSize * 0.5, -gridSize));
                points.push(new THREE.Vector3(x * 0.5, 0, 0));
                
                lineGeometry.setFromPoints(points);
                const line = new THREE.Line(lineGeometry, gridMaterial);
                leftGrid.add(line);
            }

            // ÂâµÂª∫Âè≥ÂÅ¥Á∂≤Ê†ºÔºà‰ΩøÁî®ËóçËâ≤Ôºâ
            const rightGrid = new THREE.Group();
            for (let i = -gridDivisions; i <= gridDivisions; i++) {
                const lineGeometry = new THREE.BufferGeometry();
                const points = [];
                
                // Ê∞¥Âπ≥Á∑ö
                points.push(new THREE.Vector3(0, 0, i * gridStep));
                points.push(new THREE.Vector3(gridSize, gridSize * 0.5, i * gridStep));
                
                lineGeometry.setFromPoints(points);
                const line = new THREE.Line(lineGeometry, blueGridMaterial);
                rightGrid.add(line);
            }
            
            // ÂûÇÁõ¥‰∫§ÂèâÁ∑ö
            for (let i = 0; i <= gridDivisions; i++) {
                const lineGeometry = new THREE.BufferGeometry();
                const points = [];
                
                const x = i * gridStep;
                points.push(new THREE.Vector3(x, 0, -gridSize));
                points.push(new THREE.Vector3(x + gridSize * 0.5, gridSize * 0.5, 0));
                
                lineGeometry.setFromPoints(points);
                const line = new THREE.Line(lineGeometry, blueGridMaterial);
                rightGrid.add(line);
            }

            // Ê∑ªÂä†ÊòüÊòüÊïàÊûú
            const starsGeometry = new THREE.BufferGeometry();
            const starsPositions = [];
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * gridSize * 3 - gridSize * 1.5;
                const y = Math.random() * gridSize - gridSize * 0.5;
                const z = Math.random() * gridSize * 2 - gridSize;
                starsPositions.push(x, y, z);
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsPositions, 3));
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            const stars = new THREE.Points(starsGeometry, starsMaterial);

            // Â∞áÁ∂≤Ê†ºÂíåÊòüÊòüÊ∑ªÂä†Âà∞Â†¥ÊôØ
            scene.add(leftGrid);
            scene.add(rightGrid);
            scene.add(stars);

            // Á®çÂæÆÂÇæÊñúÁ∂≤Ê†º‰ª•Áç≤ÂæóÊõ¥Â•ΩÁöÑË¶ñË¶∫ÊïàÊûú
            leftGrid.rotation.x = -Math.PI * 0.1;
            rightGrid.rotation.x = -Math.PI * 0.1;
        }
    </script>

</body>
</html>
