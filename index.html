<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Êà∞È¨•ÈôÄËû∫3D - ÊóãËΩâËÉΩÈáèÈ°ØÁ§∫Áâà</title>
    <style>
        /* Styles remain the same */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #282c34; }
        #selection-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #0f3c57, #471391); color: #ecf0f1; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; z-index: 10; padding: 10px; box-sizing: border-box; overflow-y: auto; }
        #selection-screen h2 { margin: 15px 0; font-size: clamp(1.5em, 5vw, 2.5em); text-shadow: 2px 2px 5px rgba(0,0,0,0.5); color: #e0e0e0; }
        #beyblade-options { display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; max-width: 800px; padding: 10px; }
        .bey-card { position: relative; width: clamp(280px, 90vw, 350px); height: 150px; min-height: 130px; border-radius: 12px; margin: 5px; cursor: pointer; background-color: #34495e; box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.4); border: 3px solid transparent; transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease; display: flex; flex-direction: column; }
        .bey-card:hover { transform: translateY(-10px) scale(1.03); box-shadow: 8px 12px 20px rgba(0, 0, 0, 0.5); }
        .bey-card .bey-preview { height: 60%; width: 100%; display: flex; justify-content: center; align-items: center; position: relative; }
         .bey-card .bey-symbol { font-size: 3.5em; color: rgba(255, 255, 255, 0.2); text-shadow: 2px 2px 5px rgba(0,0,0,0.4); z-index: 2; }
         .bey-card .bey-info { height: 40%; padding: 10px; box-sizing: border-box; background-color: rgba(0, 0, 0, 0.4); color: #ecf0f1; display: flex; flex-direction: column; justify-content: center; position: relative; z-index: 3; }
          .bey-card .bey-name { font-weight: bold; font-size: 1.1em; margin-bottom: 5px; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); }
          .bey-card .bey-stats { font-size: 0.85em; line-height: 1.3; color: #bdc3c7; }
        .bey-card.selected { border-color: #2ecc71; transform: translateY(-5px) scale(1.05); box-shadow: 0 0 25px rgba(46, 204, 113, 0.7); }
        #start-button { margin-top: 40px; padding: 15px 40px; font-size: 1.6em; cursor: pointer; background: linear-gradient(145deg, #2e60cc, #6d27ae); color: white; border: none; border-radius: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); transition: background 0.2s ease, transform 0.1s ease; display: none; }
        #start-button:hover { background: linear-gradient(145deg, #e33f3f, #2ebb69); }
        #start-button:active { transform: scale(0.97); }
        #start-button:disabled { background: #7f8c8d; cursor: not-allowed; opacity: 0.6; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; cursor: pointer; }
        #game-ui { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); font-size: clamp(1em, 4vw, 1.6em); color: white; background-color: rgba(44, 62, 80, 0.7); padding: 8px 15px; border-radius: 8px; z-index: 6; text-shadow: 1px 1px 3px rgba(0,0,0,0.7); display: none; pointer-events: none; text-align: center; width: 90%; max-width: 500px; margin: 0 auto; }
        #charge-bar-container { position: absolute; bottom: 5%; left: 50%; transform: translateX(-50%); width: clamp(200px, 80%, 350px); height: 30px; background-color: rgba(0, 0, 0, 0.6); border: 2px solid #95a5a6; border-radius: 18px; z-index: 6; display: none; overflow: hidden; pointer-events: none; }
        #charge-bar-fill { width: 100%; height: 100%; background: linear-gradient(to right, #e74c3c, #f39c12, #2ecc71, #f39c12, #e74c3c); border-radius: 16px; }
        #charge-indicator { position: absolute; top: -2px; bottom: -2px; left: 0%; width: 6px; background-color: rgba(255, 255, 255, 0.9); border-radius: 3px; box-shadow: 0 0 5px rgba(255, 255, 255, 0.7); transform: translateX(-50%); transition: left 0.05s linear; }

        /* --- Spin Bar Styles --- */
        .spin-bar-container { position: absolute; top: 100px; width: clamp(120px, 35%, 400px); height: 25px; background-color: rgba(0, 0, 0, 0.5); border: 3px solid #7f8c8d; border-radius: 18px; z-index: 5; overflow: hidden; display: none; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .spin-bar-fill { height: 100%; width: 100%; border-radius: 11px; transition: width 0.15s linear; background-color: #e67e22; }
        .spin-bar-label { color: white; font-size: clamp(0.8em, 3vw, 1.2em); text-shadow: 2px 2px 3px black; position: absolute; top: 50%; transform: translateY(-50%); padding: 0 15px; z-index: 8; pointer-events: none; }
        #player-spin-bar-container { left: 10px; }
        #player-spin-bar-label { left: 0; }
        #ai-spin-bar-container { right: 10px; }
        #ai-spin-bar-label { right: 0; text-align: right;}

        /* Media Queries */
        @media screen and (max-width: 480px) {
            .bey-card { height: 85px; margin: 3px; }
            .bey-card .bey-symbol { font-size: 2.5em; }
            .bey-card .bey-name { font-size: 1em; }
            .bey-card .bey-stats { font-size: 0.75em; }
            #start-button { margin-top: 20px; padding: 10px 30px; font-size: 1.3em; }
        }
        @media screen and (max-width: 360px) {
            .spin-bar-container { height: 20px; }
            .spin-bar-label { padding: 0 8px; }
            #game-ui { padding: 6px 12px; }
        }
        @media screen and (orientation: landscape) and (max-height: 500px) {
            #selection-screen h2 { margin: 10px 0; }
            .bey-card { height: 80px; }
            #start-button { margin-top: 15px; }
            .spin-bar-container { top: 10px; }
            #charge-bar-container { bottom: 3%; }
        }
    </style>
</head>
<body>
    <div id="selection-screen"><h2>Make your choice</h2><div id="beyblade-options"></div><button id="start-button" disabled>Start Game</button></div>
    <div id="game-container">
        <div id="player-spin-bar-container" class="spin-bar-container">
            <div id="player-spin-bar-fill" class="spin-bar-fill"></div>
            <span id="player-spin-bar-label" class="spin-bar-label">Áé©ÂÆ∂</span>
        </div>
        <div id="ai-spin-bar-container" class="spin-bar-container">
            <div id="ai-spin-bar-fill" class="spin-bar-fill"></div>
             <span id="ai-spin-bar-label" class="spin-bar-label">AI</span>
        </div>
        <div id="charge-bar-container"><div id="charge-bar-fill"></div><div id="charge-indicator"></div></div>
    </div>
    <div id="game-ui">Wait for Start...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- Configuration ---
        const BEYBLADE_TYPES = [
             { id: 'pegasus', name: 'Grok', symbol: '‚≠ê', color: 0x4488ff, colorHex: '#3160cb', weight: 1.0, initialSpeed: 0.15, stamina: 120 },
             { id: 'l-drago', name: 'Gemini', symbol: 'üî•', color: 0xff4444, colorHex: '#8b3261', weight: 1.3, initialSpeed: 0.12, stamina: 110 },
             { id: 'libra', name: 'Chat-GPT', symbol: '‚öñÔ∏è', color: 0x44ff44, colorHex: '#438b59', weight: 1.1, initialSpeed: 0.11, stamina: 130 }
        ];
        const ORIGINAL_ARENA_RADIUS = 15;
        const MIN_ARENA_RADIUS = 15;
        const MIN_REF_SCREEN_DIM = 360;
        const MAX_REF_SCREEN_DIM = 900;
        const BEYBLADE_RADIUS = 2;

        // -- Physics & Collision Parameters --
        const GRAVITY_TOWARDS_CENTER = 0.0300; const FRICTION = 0.0010; const SPIN_FRICTION = 0.0150;
        const BOUNDARY_ENERGY_LOSS = 0.3; const COLLISION_ENERGY_LOSS = 0.25; const INTENSITY_MULTIPLIER = 1.9;
        const TANGENTIAL_KICK_FACTOR = 30; const COLLISION_SPIN_LOSS_FACTOR = 2.0; const MAX_VELOCITY = 0.6;
        const OBSTACLE_COLLISION_ENERGY_LOSS = 0.35; // Á∑öÊÄßËÉΩÈáèÊêçÂ§±
        const OBSTACLE_SEPARATION_FORCE = 0.1;
        const OBSTACLE_SPIN_LOSS_FACTOR = 6; // <--- Á¢∞ÊíûÈöúÁ§ôÁâ©ÊôÇÁöÑÊóãËΩâËÉΩÈáèÊêçÂ§±‰øÇÊï∏

        // -- Launch Mechanic Parameters --
        const MIN_LAUNCH_POWER = 0.25; const INDICATOR_SPEED = 4.0;

        // --- Spark Particle Configuration ---
        const SPARK_COUNT = 90; const SPARK_LIFESPAN = 0.45; const SPARK_SPEED_MIN = 15.0; const SPARK_SPEED_MAX = 35.0; const SPARK_BASE_SIZE = 5; const SPARK_COLOR = 0xff8c00; const SPARK_POOL_SIZE = 20; const SPARK_GRAVITY = -12.0;

        // --- Obstacle Configuration ---
        const OBSTACLE_BASE_WIDTH = BEYBLADE_RADIUS * 1.8;
        const OBSTACLE_HEIGHT = BEYBLADE_RADIUS * 2.3; // Âä†È´òÁöÑÈ´òÂ∫¶
        const OBSTACLE_DEPTH = 3;
        const OBSTACLE_PLACEMENT_FACTOR = 0.8;
        const OBSTACLE_COLOR = 0x8866cc;

        // --- Global Variables ---
        let scene, camera, renderer; let arenaMesh, rimMesh; let obstacleMeshes = [];
        let playerBeyData = { mesh: null, type: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0, maxStamina: 0 }; let aiBeyData = { mesh: null, type: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0, maxStamina: 0 };
        let gameState = 'selecting'; let animationFrameId; let selectedPlayerTypeId = null; let launchInitiated = false; let indicatorPosition = 0; let indicatorDirection = 1; let captureIndicatorPosition = -1;
        let sparkPool = []; let sparkPoolIndex = 0; let sparkGeometry = null; let sparkTexture = null; let initialCameraDir = null;
        let arenaRadius = ORIGINAL_ARENA_RADIUS; let launchDistance = arenaRadius * 0.65;
        const materialsCache = {}; function getMaterial(color, options = {}) { const key = `${color}_${JSON.stringify(options)}`; if (!materialsCache[key]) { materialsCache[key] = new THREE.MeshStandardMaterial({ color, ...options }); } return materialsCache[key]; }
        const selectionScreen = document.getElementById('selection-screen'); const beybladeOptionsContainer = document.getElementById('beyblade-options'); const startButton = document.getElementById('start-button'); const gameContainer = document.getElementById('game-container'); const gameUi = document.getElementById('game-ui'); const chargeBarContainer = document.getElementById('charge-bar-container'); const chargeBarFill = document.getElementById('charge-bar-fill'); const chargeIndicator = document.getElementById('charge-indicator');
        const playerSpinBarContainer = document.getElementById('player-spin-bar-container'); const playerSpinFill = document.getElementById('player-spin-bar-fill'); const playerSpinLabel = document.getElementById('player-spin-bar-label'); const aiSpinBarContainer = document.getElementById('ai-spin-bar-container'); const aiSpinFill = document.getElementById('ai-spin-bar-fill'); const aiSpinLabel = document.getElementById('ai-spin-bar-label');
        const clock = new THREE.Clock();

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x231948);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, ORIGINAL_ARENA_RADIUS * 1.5, ORIGINAL_ARENA_RADIUS * 1.1); camera.lookAt(0, 0, 0); initialCameraDir = camera.position.clone().normalize();
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.outputEncoding = THREE.sRGBEncoding; gameContainer.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); directionalLight.position.set(10, 20, 15); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50; directionalLight.shadow.camera.left = -ORIGINAL_ARENA_RADIUS * 1.5; directionalLight.shadow.camera.right = ORIGINAL_ARENA_RADIUS * 1.5; directionalLight.shadow.camera.top = ORIGINAL_ARENA_RADIUS * 1.5; directionalLight.shadow.camera.bottom = -ORIGINAL_ARENA_RADIUS * 1.5; scene.add(directionalLight); const fillLight = new THREE.HemisphereLight(0x6060aa, 0x404088, 0.2); scene.add(fillLight);
            arenaRadius = ORIGINAL_ARENA_RADIUS; launchDistance = arenaRadius * 0.65;
            createArena(ORIGINAL_ARENA_RADIUS);
            initSparkSystem(); window.addEventListener('resize', onWindowResize, false); setupSelectionUI(); setupLaunchControls(); updateArenaSizeAndDependents();
        }

        // --- Arena Creation (with inward-pointing obstacles) ---
        function createArena(radiusToBuild = ORIGINAL_ARENA_RADIUS) {
            // Floor & Rim
            const floorGeometry = new THREE.CircleGeometry(radiusToBuild, 64);
            const floorMaterial = getMaterial(0xff6942, { metalness: 0.3, roughness: 0.6, side: THREE.DoubleSide });
            arenaMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            arenaMesh.rotation.x = -Math.PI / 2; arenaMesh.receiveShadow = true; scene.add(arenaMesh);
            const rimGeometry = new THREE.RingGeometry(radiusToBuild, radiusToBuild + 0.6, 64);
            const rimMaterial = getMaterial(0x454dc4, { metalness: 0.5, roughness: 0.4, side: THREE.DoubleSide });
            rimMesh = new THREE.Mesh(rimGeometry, rimMaterial);
            rimMesh.rotation.x = -Math.PI / 2; rimMesh.position.y = 0.02; rimMesh.receiveShadow = true; scene.add(rimMesh);

            // Obstacles
            const obstacleMaterial = getMaterial(OBSTACLE_COLOR, { metalness: 0.7, roughness: 0.5 });
            const triangleShape = new THREE.Shape(); const halfBase = OBSTACLE_BASE_WIDTH / 2; triangleShape.moveTo(-halfBase, 0); triangleShape.lineTo(halfBase, 0); triangleShape.lineTo(0, OBSTACLE_HEIGHT); triangleShape.lineTo(-halfBase, 0);
            const extrudeSettings = { depth: OBSTACLE_DEPTH, bevelEnabled: false }; const obstacleGeometry = new THREE.ExtrudeGeometry(triangleShape, extrudeSettings); obstacleGeometry.computeVertexNormals();
            const placements = [
                { x: 0, z: radiusToBuild * OBSTACLE_PLACEMENT_FACTOR, rotZ: Math.PI, normal: new THREE.Vector3(0, 0, 1) },    // Top (Tip In, Base Out +Z)
                { x: 0, z: -radiusToBuild * OBSTACLE_PLACEMENT_FACTOR, rotZ: 0, normal: new THREE.Vector3(0, 0, -1) },   // Bottom (Tip In, Base Out -Z)
                { x: radiusToBuild * OBSTACLE_PLACEMENT_FACTOR, z: 0, rotZ: Math.PI / 2, normal: new THREE.Vector3(1, 0, 0) }, // Right (Tip In, Base Out +X)
                { x: -radiusToBuild * OBSTACLE_PLACEMENT_FACTOR, z: 0, rotZ: -Math.PI / 2, normal: new THREE.Vector3(-1, 0, 0) } // Left (Tip In, Base Out -X)
            ];
            obstacleMeshes = [];
            placements.forEach((p) => {
                const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacleMesh.rotation.x = Math.PI / 2; obstacleMesh.position.y = OBSTACLE_DEPTH / 2;
                obstacleMesh.position.x = p.x; obstacleMesh.position.z = p.z; obstacleMesh.rotation.z = p.rotZ;
                obstacleMesh.castShadow = true; obstacleMesh.receiveShadow = true;
                obstacleMesh.userData = { faceNormal: p.normal };
                scene.add(obstacleMesh); obstacleMeshes.push(obstacleMesh);
            });
        }

        // --- Dynamic Size Updates ---
        function updateArenaSizeAndDependents() {
            const currentMinScreenDim = Math.min(window.innerWidth, window.innerHeight); const screenRange = MAX_REF_SCREEN_DIM - MIN_REF_SCREEN_DIM; const radiusRange = ORIGINAL_ARENA_RADIUS - MIN_ARENA_RADIUS;
            let scaleFactor = screenRange <= 0 ? 1.0 : Math.max(0, Math.min(1, (currentMinScreenDim - MIN_REF_SCREEN_DIM) / screenRange));
            const newRadius = MIN_ARENA_RADIUS + radiusRange * scaleFactor; arenaRadius = newRadius; launchDistance = arenaRadius * 0.65;
            const modelScale = arenaRadius / ORIGINAL_ARENA_RADIUS;
            if (arenaMesh) arenaMesh.scale.set(modelScale, 1, modelScale); if (rimMesh) rimMesh.scale.set(modelScale, 1, modelScale);
            if (obstacleMeshes.length > 0) {
                const placements = [ { x: 0, z: arenaRadius * OBSTACLE_PLACEMENT_FACTOR }, { x: 0, z: -arenaRadius * OBSTACLE_PLACEMENT_FACTOR }, { x: arenaRadius * OBSTACLE_PLACEMENT_FACTOR, z: 0 }, { x: -arenaRadius * OBSTACLE_PLACEMENT_FACTOR, z: 0 } ];
                obstacleMeshes.forEach((mesh, index) => { mesh.position.x = placements[index].x; mesh.position.z = placements[index].z; /* mesh.scale.set(modelScale, modelScale, modelScale); // Optional scaling */ });
            }
            if (!scene.fog) { scene.fog = new THREE.Fog(scene.background, arenaRadius * 2.5, arenaRadius * 5); } else { scene.fog.near = arenaRadius * 2.5; scene.fog.far = arenaRadius * 5; }
            adjustCameraToFitArena();
        }
        function adjustCameraToFitArena() {
            if (!camera || !initialCameraDir) return; const aspect = camera.aspect; const vFovRad = THREE.MathUtils.degToRad(camera.fov); const hFovRad = 2 * Math.atan(Math.tan(vFovRad / 2) * aspect); const margin = 1.15; const targetRadius = arenaRadius * margin; const distV = targetRadius / Math.tan(vFovRad / 2); const distH = targetRadius / Math.tan(hFovRad / 2); const requiredDistance = Math.max(distV, distH); camera.position.copy(initialCameraDir).multiplyScalar(requiredDistance); camera.lookAt(0, 0, 0);
        }

        // --- Spark System ---
        function initSparkSystem() {
            sparkTexture = createSparkTexture(); sparkGeometry = new THREE.BufferGeometry(); const positions = new Float32Array(SPARK_COUNT * 3); const velocities = new Float32Array(SPARK_COUNT * 3); const startTimes = new Float32Array(SPARK_COUNT); const baseSizes = new Float32Array(SPARK_COUNT); sparkGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); sparkGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3)); sparkGeometry.setAttribute('startTime', new THREE.BufferAttribute(startTimes, 1)); sparkGeometry.setAttribute('baseSize', new THREE.BufferAttribute(baseSizes, 1)); const baseSparkMaterial = new THREE.PointsMaterial({ size: SPARK_BASE_SIZE, color: SPARK_COLOR, map: sparkTexture, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false, sizeAttenuation: true, opacity: 1.0 }); for (let i = 0; i < SPARK_POOL_SIZE; i++) { const materialClone = baseSparkMaterial.clone(); const points = new THREE.Points(sparkGeometry, materialClone); points.visible = false; points.userData = { isActive: false, activationTime: 0 }; sparkPool.push(points); scene.add(points); }
        }
        function createSparkTexture() {
             const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64; const context = canvas.getContext('2d'); const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32); gradient.addColorStop(0, 'rgba(255, 255, 220, 1)'); gradient.addColorStop(0.1, 'rgba(255, 200, 100, 1)'); gradient.addColorStop(0.4, 'rgba(255, 165, 0, 0.6)'); gradient.addColorStop(1, 'rgba(255, 140, 0, 0)'); context.fillStyle = gradient; context.fillRect(0, 0, 64, 64); const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; return texture;
        }
        function triggerSparks(position, intensity) {
            const points = sparkPool[sparkPoolIndex]; if (!points) return; const geometry = points.geometry; const attributes = geometry.attributes; if (!attributes.velocity || !attributes.startTime || !attributes.position || !attributes.baseSize) { console.error("Spark geometry attributes missing!"); return; } const velocities = attributes.velocity.array; const startTimes = attributes.startTime.array; const positions = attributes.position.array; const baseSizes = attributes.baseSize.array; points.position.copy(position); const currentTime = clock.elapsedTime; const intensityFactor = Math.min(1, Math.sqrt(intensity / 20)); const speedRange = SPARK_SPEED_MAX - SPARK_SPEED_MIN; for (let i = 0; i < SPARK_COUNT; i++) { const i3 = i * 3; const angle = Math.random() * Math.PI * 2; const heightFactor = Math.random() * 2 - 1; const radius = Math.random(); const dirX = Math.cos(angle) * radius; const dirY = Math.abs(heightFactor) + 0.2; const dirZ = Math.sin(angle) * radius; const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ); const speed = SPARK_SPEED_MIN + Math.random() * speedRange * intensityFactor; velocities[i3 + 0] = (dirX / length) * speed * (1 + Math.random() * 0.5); velocities[i3 + 1] = (dirY / length) * speed * (1 + Math.random() * 0.5); velocities[i3 + 2] = (dirZ / length) * speed * (1 + Math.random() * 0.5); positions[i3 + 0] = 0; positions[i3 + 1] = 0; positions[i3 + 2] = 0; startTimes[i] = currentTime; baseSizes[i] = SPARK_BASE_SIZE * (0.5 + Math.random()); } attributes.position.needsUpdate = true; attributes.velocity.needsUpdate = true; attributes.startTime.needsUpdate = true; attributes.baseSize.needsUpdate = true; points.material.opacity = 1.0; points.visible = true; points.userData.isActive = true; points.userData.activationTime = currentTime; sparkPoolIndex = (sparkPoolIndex + 1) % SPARK_POOL_SIZE;
        }

        // --- UI & Game Flow ---
        function setupSelectionUI() {
             beybladeOptionsContainer.innerHTML = ''; if (!beybladeOptionsContainer) { console.error("Element with ID 'beyblade-options' not found!"); return; } BEYBLADE_TYPES.forEach(type => { const card = document.createElement('div'); card.classList.add('bey-card'); card.dataset.beyId = type.id; const previewArea = document.createElement('div'); previewArea.classList.add('bey-preview'); previewArea.style.background = `radial-gradient(ellipse at top, ${lightenColor(type.colorHex, 30)}, ${type.colorHex} 70%)`; const symbolSpan = document.createElement('span'); symbolSpan.classList.add('bey-symbol'); symbolSpan.textContent = type.symbol || 'üåÄ'; previewArea.appendChild(symbolSpan); card.appendChild(previewArea); const infoDiv = document.createElement('div'); infoDiv.classList.add('bey-info'); infoDiv.innerHTML = `<div class="bey-name">${type.name}</div><div class="bey-stats">È´îÈáç: ${type.weight.toFixed(1)} | ÈÄüÂ∫¶: ${type.initialSpeed.toFixed(2)} | ËÄêÂäõ: ${type.stamina}</div>`; card.appendChild(infoDiv); card.addEventListener('click', () => { document.querySelectorAll('.bey-card').forEach(c => c.classList.remove('selected')); card.classList.add('selected'); selectedPlayerTypeId = type.id; if(startButton) { startButton.disabled = false; startButton.style.display = 'inline-block'; } }); beybladeOptionsContainer.appendChild(card); }); if(startButton) startButton.addEventListener('click', startGame);
        }
        function lightenColor(hex, percent) {
              hex = hex.replace(/^#/, ''); const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); const newR = Math.min(255, r + Math.floor(255 * (percent / 100))); const newG = Math.min(255, g + Math.floor(255 * (percent / 100))); const newB = Math.min(255, b + Math.floor(255 * (percent / 100))); return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }
        function startGame() {
             if (!selectedPlayerTypeId) return; gameState = 'preparing'; launchInitiated = false; captureIndicatorPosition = -1; indicatorPosition = Math.random(); indicatorDirection = Math.random() < 0.5 ? 1 : -1; selectionScreen.style.display = 'none'; gameContainer.style.display = 'block'; gameUi.style.display = 'block'; gameUi.textContent = "Ê∫ñÂÇô..."; playerBeyData.type = BEYBLADE_TYPES.find(b => b.id === selectedPlayerTypeId); const availableAiTypes = BEYBLADE_TYPES.filter(b => b.id !== selectedPlayerTypeId); aiBeyData.type = availableAiTypes[Math.floor(Math.random() * availableAiTypes.length)]; playerBeyData.maxStamina = playerBeyData.type.stamina; aiBeyData.maxStamina = aiBeyData.type.stamina; resetBattle(); setupBattle(); if (playerSpinBarContainer) playerSpinBarContainer.style.display = 'block'; if (aiSpinBarContainer) aiSpinBarContainer.style.display = 'block'; if (playerSpinFill) { playerSpinFill.style.width = '100%'; playerSpinFill.style.backgroundColor = playerBeyData.type.colorHex; playerSpinLabel.textContent = playerBeyData.type.name; } if (aiSpinFill) { aiSpinFill.style.width = '100%'; aiSpinFill.style.backgroundColor = aiBeyData.type.colorHex; aiSpinLabel.textContent = aiBeyData.type.name; } setTimeout(() => { gameState = 'launching'; if(chargeBarContainer) chargeBarContainer.style.display = 'block'; if(chargeIndicator) chargeIndicator.style.left = `${indicatorPosition * 100}%`; gameUi.textContent = "ÈªûÊìäËìÑÂäõ!"; if (!animationFrameId) { animate(); } }, 500);
        }
        function setupLaunchControls() {
              if(gameContainer) gameContainer.addEventListener('pointerdown', captureLaunchTiming);
        }
        function captureLaunchTiming(event) {
             if (gameState === 'launching' && !launchInitiated) { event.preventDefault(); captureIndicatorPosition = indicatorPosition; initiateLaunch(); }
        }
        function initiateLaunch() {
              if (launchInitiated || captureIndicatorPosition < 0) return; launchInitiated = true; if(chargeBarContainer) chargeBarContainer.style.display = 'none'; const deviation = Math.abs(captureIndicatorPosition - 0.5); const timedPower = 1.0 - deviation * 2; const launchPowerFactor = MIN_LAUNCH_POWER + timedPower * (1.0 - MIN_LAUNCH_POWER); playerBeyData.angularVelocity = playerBeyData.maxStamina * launchPowerFactor; const aiLaunchPowerFactor = MIN_LAUNCH_POWER + Math.random() * (1.0 - MIN_LAUNCH_POWER); aiBeyData.angularVelocity = aiBeyData.maxStamina * aiLaunchPowerFactor; playerBeyData.velocity.set(launchDistance * 0.8, 0, (Math.random() - 0.5) * launchDistance * 0.8).normalize().multiplyScalar(playerBeyData.type.initialSpeed * (0.8 + launchPowerFactor * 0.4)); aiBeyData.velocity.set(-launchDistance * 0.8, 0, (Math.random() - 0.5) * launchDistance * 0.8).normalize().multiplyScalar(aiBeyData.type.initialSpeed * (0.8 + aiLaunchPowerFactor * 0.4)); gameUi.textContent = "Battle Start!"; setTimeout(() => { if (gameState === 'launching') gameState = 'fighting'; }, 100);
        }
        function resetBattle() {
             if (playerBeyData.mesh) scene.remove(playerBeyData.mesh); if (aiBeyData.mesh) scene.remove(aiBeyData.mesh); playerBeyData = { ...playerBeyData, mesh: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0 }; aiBeyData = { ...aiBeyData, mesh: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0 }; sparkPool.forEach(points => { if (points.userData.isActive) { points.visible = false; points.userData.isActive = false; points.material.opacity = 1.0; points.material.size = SPARK_BASE_SIZE; } }); sparkPoolIndex = 0; if (playerSpinBarContainer) playerSpinBarContainer.style.display = 'none'; if (aiSpinBarContainer) aiSpinBarContainer.style.display = 'none';
        }
        function createBeybladeMesh(beyType) {
            const group = new THREE.Group(); const radius = BEYBLADE_RADIUS; const mainHeight = radius * 0.6; const detailHeight = radius * 0.4; const mainMat = getMaterial(beyType.color, { metalness: 0.5, roughness: 0.4 }); const metalMat = getMaterial(0xcccccc, { metalness: 0.8, roughness: 0.3 }); const darkMetalMat = getMaterial(0x555555, { metalness: 0.7, roughness: 0.4 }); const accentMat = getMaterial(0xffff00, { metalness: 0.6, roughness: 0.4 }); let lowestY = 0;
            switch (beyType.id) { case 'pegasus': { const bodyGeo = new THREE.CylinderGeometry(radius * 0.8, radius * 0.5, mainHeight, 16); const bodyMesh = new THREE.Mesh(bodyGeo, mainMat); bodyMesh.position.y = detailHeight + mainHeight / 2; bodyMesh.castShadow = true; group.add(bodyMesh); const ringGeo = new THREE.TorusGeometry(radius * 0.9, radius * 0.15, 8, 32); const ringMesh = new THREE.Mesh(ringGeo, metalMat); ringMesh.rotation.x = Math.PI / 2; ringMesh.position.y = detailHeight * 0.8; ringMesh.castShadow = true; group.add(ringMesh); const baseGeo = new THREE.ConeGeometry(radius * 0.6, detailHeight, 16); const baseMesh = new THREE.Mesh(baseGeo, metalMat); baseMesh.position.y = detailHeight / 2; baseMesh.castShadow = true; group.add(baseMesh); lowestY = 0; break; } case 'l-drago': { const bodyGeo = new THREE.ConeGeometry(radius * 0.7, mainHeight * 1.2, 16); const bodyMesh = new THREE.Mesh(bodyGeo, mainMat); bodyMesh.position.y = detailHeight + mainHeight * 0.6; bodyMesh.castShadow = true; group.add(bodyMesh); const wheelGeo = new THREE.CylinderGeometry(radius * 1.0, radius * 0.9, detailHeight * 0.8, 16); const wheelMesh = new THREE.Mesh(wheelGeo, darkMetalMat); wheelMesh.position.y = detailHeight * 0.6; wheelMesh.castShadow = true; group.add(wheelMesh); const baseGeo = new THREE.CylinderGeometry(radius * 0.4, radius * 0.2, detailHeight * 0.4, 16); const baseMesh = new THREE.Mesh(baseGeo, darkMetalMat); baseMesh.position.y = detailHeight * 0.2; baseMesh.castShadow = true; group.add(baseMesh); lowestY = 0; break; } case 'libra': default: { const bodyGeo = new THREE.CylinderGeometry(radius * 0.95, radius * 0.85, mainHeight * 0.6, 24); const bodyMesh = new THREE.Mesh(bodyGeo, mainMat); bodyMesh.position.y = detailHeight + (mainHeight * 0.6) / 2; bodyMesh.castShadow = true; group.add(bodyMesh); const ringGeo = new THREE.TorusGeometry(radius * 0.8, radius * 0.18, 8, 32); const ringMesh = new THREE.Mesh(ringGeo, metalMat); ringMesh.rotation.x = Math.PI / 2; ringMesh.position.y = detailHeight * 0.7; ringMesh.castShadow = true; group.add(ringMesh); const baseTopGeo = new THREE.CylinderGeometry(radius * 0.6, radius * 0.7, detailHeight * 0.4, 16); const baseTopMesh = new THREE.Mesh(baseTopGeo, accentMat); baseTopMesh.position.y = detailHeight * 0.6; baseTopMesh.castShadow = true; group.add(baseTopMesh); const baseBottomGeo = new THREE.CylinderGeometry(radius * 0.7, radius * 0.5, detailHeight * 0.4, 16); const baseBottomMesh = new THREE.Mesh(baseBottomGeo, accentMat); baseBottomMesh.position.y = detailHeight * 0.2; baseBottomMesh.castShadow = true; group.add(baseBottomMesh); lowestY = 0; break; } }
            group.position.y = -lowestY; const meshBaseOffset = -lowestY; return { mesh: group, baseOffset: meshBaseOffset };
        }
        function setupBattle() {
            const playerResult = createBeybladeMesh(playerBeyData.type); playerBeyData.mesh = playerResult.mesh; playerBeyData.baseOffset = playerResult.baseOffset; playerBeyData.mesh.position.set(-launchDistance, playerBeyData.baseOffset, (Math.random() - 0.5) * 4); scene.add(playerBeyData.mesh); const aiResult = createBeybladeMesh(aiBeyData.type); aiBeyData.mesh = aiResult.mesh; aiBeyData.baseOffset = aiResult.baseOffset; aiBeyData.mesh.position.set(launchDistance, aiBeyData.baseOffset, (Math.random() - 0.5) * 4); scene.add(aiBeyData.mesh);
        }

        // --- Game Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate); const delta = clock.getDelta(); const currentTime = clock.elapsedTime;
            if (gameState === 'launching' && !launchInitiated) { indicatorPosition += indicatorDirection * INDICATOR_SPEED * delta; if (indicatorPosition >= 1.0) { indicatorPosition = 1.0; indicatorDirection = -1; } else if (indicatorPosition <= 0.0) { indicatorPosition = 0.0; indicatorDirection = 1; } if (chargeIndicator) { chargeIndicator.style.left = `${indicatorPosition * 100}%`; } }
            if (gameState === 'fighting') {
                updatePhysics(playerBeyData, delta); updatePhysics(aiBeyData, delta);
                handleCollisions(delta); checkWinConditions();
                const playerSpinPercent = Math.max(0, Math.min(100, (playerBeyData.angularVelocity / playerBeyData.maxStamina) * 100)); const aiSpinPercent = Math.max(0, Math.min(100, (aiBeyData.angularVelocity / aiBeyData.maxStamina) * 100)); if (playerSpinFill) playerSpinFill.style.width = playerSpinPercent + '%'; if (aiSpinFill) aiSpinFill.style.width = aiSpinPercent + '%';
            }
            sparkPool.forEach(points => { if (points.userData.isActive) { const activationTime = points.userData.activationTime; const elapsedTime = currentTime - activationTime; const lifeRatio = Math.min(1.0, elapsedTime / SPARK_LIFESPAN); if (lifeRatio >= 1.0) { points.visible = false; points.userData.isActive = false; } else { points.material.opacity = Math.pow(1.0 - lifeRatio, 1.5); points.material.size = SPARK_BASE_SIZE * (1.0 - lifeRatio * 0.8); const geometry = points.geometry; const attributes = geometry.attributes; const positions = attributes.position.array; const velocities = attributes.velocity.array; const startTimes = attributes.startTime.array; let needsPosUpdate = false; for (let i = 0; i < SPARK_COUNT; i++) { if (startTimes[i] === activationTime) { const i3 = i * 3; const particleElapsedTime = currentTime - startTimes[i]; positions[i3 + 0] = velocities[i3 + 0] * particleElapsedTime; positions[i3 + 1] = velocities[i3 + 1] * particleElapsedTime + 0.5 * SPARK_GRAVITY * particleElapsedTime * particleElapsedTime; positions[i3 + 2] = velocities[i3 + 2] * particleElapsedTime; needsPosUpdate = true; } } if(needsPosUpdate) { attributes.position.needsUpdate = true; } } } });
            renderer.render(scene, camera);
        }

        // --- Physics & Logic (MODIFIED: Includes obstacle spin loss) ---
        function updatePhysics(beyData, delta) {
            const groundY = beyData.baseOffset;
            if (!beyData.mesh || beyData.isOut || beyData.angularVelocity <= 0) { if (beyData.angularVelocity <= 0 && !beyData.isOut && beyData.mesh) { beyData.velocity.set(0, 0, 0); if (beyData.mesh.position.y !== groundY) beyData.mesh.position.y = groundY; } return; }
            const mesh = beyData.mesh; const velocity = beyData.velocity; const type = beyData.type; const frictionFactor = Math.pow(1.0 - FRICTION, delta * 60); velocity.multiplyScalar(frictionFactor); const spinDrainMultiplier = Math.max(0.6, (2.2 - type.stamina / 100)); beyData.angularVelocity -= SPIN_FRICTION * spinDrainMultiplier * delta * 60; beyData.angularVelocity = Math.max(0, beyData.angularVelocity);
            if (GRAVITY_TOWARDS_CENTER > 0) { const centerPull = mesh.position.clone().setY(0).negate(); const distFromCenter = centerPull.length(); const randomAngle = Math.random() * Math.PI * 2; const randomOffset = new THREE.Vector3(Math.cos(randomAngle), 0, Math.sin(randomAngle)); const centerInfluence = Math.min(1.0, distFromCenter / (arenaRadius * 0.8)); const randomInfluence = 1 - centerInfluence; centerPull.normalize(); const finalDirection = centerPull.multiplyScalar(centerInfluence).add(randomOffset.multiplyScalar(randomInfluence)).normalize(); const pullStrength = GRAVITY_TOWARDS_CENTER * (0.8 + Math.random() * 0.4); velocity.add(finalDirection.multiplyScalar(pullStrength * delta * 60 / type.weight)); }
            mesh.position.addScaledVector(velocity, delta * 60); mesh.rotation.y += beyData.angularVelocity * 0.1 * delta * 60;
            let hitObstacle = false;
            const beyPosXZ = new THREE.Vector2(mesh.position.x, mesh.position.z);
            const collisionCheckRadiusSq = Math.pow(OBSTACLE_BASE_WIDTH + BEYBLADE_RADIUS, 2);

            // Obstacle Collision Check
            for (const obstacle of obstacleMeshes) {
                const obsPosXZ = new THREE.Vector2(obstacle.position.x, obstacle.position.z);
                const distSq = beyPosXZ.distanceToSquared(obsPosXZ);
                if (distSq < collisionCheckRadiusSq) {
                    const obsHalfWidth = OBSTACLE_BASE_WIDTH / 2;
                    const collisionRadiusCheck = BEYBLADE_RADIUS + obsHalfWidth;
                    const relativePos = mesh.position.clone().sub(obstacle.position);
                    relativePos.applyAxisAngle(new THREE.Vector3(0, 1, 0), -obstacle.rotation.y);

                    // Simplified AABB check
                    if (Math.abs(relativePos.x) < collisionRadiusCheck && Math.abs(relativePos.z) < collisionRadiusCheck * 1.5) {
                        const collisionNormal = obstacle.userData.faceNormal.clone();
                        const relativeVelocity = velocity.clone();
                        const velAlongNormal = relativeVelocity.dot(collisionNormal);

                        if (velAlongNormal > 0) { // Moving towards outward-facing normal
                            const velocityBeforeBounce = velocity.clone();
                            velocity.reflect(collisionNormal); // Reflect linear velocity

                            const energyLoss = OBSTACLE_COLLISION_ENERGY_LOSS * (0.8 + Math.random() * 0.4);
                            velocity.multiplyScalar(1.0 - energyLoss);

                            // --- Subtract Spin Energy ---
                            const impactSpeed = Math.abs(velAlongNormal);
                            const spinLossAmount = (impactSpeed * OBSTACLE_SPIN_LOSS_FACTOR) / type.weight; // Factor in weight
                            beyData.angularVelocity = Math.max(0, beyData.angularVelocity - spinLossAmount);
                            // --- End Subtract Spin Energy ---

                            mesh.position.addScaledVector(collisionNormal, OBSTACLE_SEPARATION_FORCE); // Push away

                            const sparkPosition = mesh.position.clone(); sparkPosition.y = beyData.baseOffset + BEYBLADE_RADIUS * 0.3;
                            const sparkIntensity = impactSpeed * 45 + 15;
                            triggerSparks(sparkPosition, sparkIntensity);

                            hitObstacle = true;
                            break;
                        }
                    }
                }
            }

            // Boundary collision (only if not hit obstacle)
            if (!hitObstacle) {
                const distanceFromCenter = mesh.position.clone().setY(0).length();
                if (distanceFromCenter > arenaRadius - BEYBLADE_RADIUS) {
                    const normal = mesh.position.clone().setY(0).normalize().negate(); const velocityBeforeBounce = velocity.clone(); const deflectionAngle = (Math.random() - 0.5) * Math.PI * 0.6; normal.applyAxisAngle(new THREE.Vector3(0, 1, 0), deflectionAngle); velocity.reflect(normal); const energyLoss = BOUNDARY_ENERGY_LOSS * (0.8 + Math.random() * 0.4); velocity.multiplyScalar(1.0 - energyLoss); const sparkPosition = mesh.position.clone().setY(0).setLength(arenaRadius - BEYBLADE_RADIUS * 0.5); sparkPosition.y = beyData.baseOffset + BEYBLADE_RADIUS * 0.3; const impactSpeed = velocityBeforeBounce.dot(normal.clone().negate()); const sparkIntensity = Math.abs(impactSpeed) * 35 + 10; triggerSparks(sparkPosition, sparkIntensity); const correctionDir = mesh.position.clone().setY(0).normalize(); const correctedRadiusPos = (arenaRadius - BEYBLADE_RADIUS - 0.01) * (0.99 + Math.random() * 0.02); mesh.position.x = correctionDir.x * correctedRadiusPos; mesh.position.z = correctionDir.z * correctedRadiusPos; if (velocity.dot(correctionDir) > 0) { velocity.projectOnVector(normal); }
                }
            }
            mesh.position.y = groundY;
        }

        // --- Beyblade Collision ---
        function handleCollisions(delta) {
            if (!playerBeyData.mesh || !aiBeyData.mesh || playerBeyData.isOut || aiBeyData.isOut || gameState !== 'fighting') return; const playerGroundY = playerBeyData.baseOffset; const aiGroundY = aiBeyData.baseOffset; const pos1 = playerBeyData.mesh.position; const pos2 = aiBeyData.mesh.position; const pos1_xz = new THREE.Vector2(pos1.x, pos1.z); const pos2_xz = new THREE.Vector2(pos2.x, pos2.z); const distSq = pos1_xz.distanceToSquared(pos2_xz); const combinedRadius = BEYBLADE_RADIUS * 2; if (distSq < combinedRadius * combinedRadius && distSq > 0.0001) { const v1 = playerBeyData.velocity; const v2 = aiBeyData.velocity; const m1 = playerBeyData.type.weight; const m2 = aiBeyData.type.weight; const collisionNormal = pos1.clone().sub(pos2).setY(0).normalize(); const relativeVelocity = v1.clone().sub(v2); const velAlongNormal = relativeVelocity.dot(collisionNormal); if (velAlongNormal > 0) return; const restitution = 1.0 - COLLISION_ENERGY_LOSS; let j = -(1 + restitution) * velAlongNormal; j /= (1 / m1) + (1 / m2); j *= INTENSITY_MULTIPLIER; const collisionIntensity = Math.abs(j) * 1.0 + 5; const sparkPos1 = pos1.clone(); sparkPos1.y += BEYBLADE_RADIUS * 0.2; triggerSparks(sparkPos1, collisionIntensity); const sparkPos2 = pos2.clone(); sparkPos2.y += BEYBLADE_RADIUS * 0.2; triggerSparks(sparkPos2, collisionIntensity); if (TANGENTIAL_KICK_FACTOR > 0) { let tangent = new THREE.Vector3(-collisionNormal.z, 0, collisionNormal.x).normalize(); const spinDiff = playerBeyData.angularVelocity - aiBeyData.angularVelocity; if (spinDiff > 0) { tangent.multiplyScalar(1); } else { tangent.multiplyScalar(-1); } const randomAngle = (Math.random() - 0.5) * Math.PI * 0.5; tangent.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle); const spinFactor = Math.abs(spinDiff) / Math.max(playerBeyData.maxStamina, aiBeyData.maxStamina); const tangentialImpulseMagnitude = Math.abs(j) * TANGENTIAL_KICK_FACTOR * (1 + spinFactor); const tangentialImpulse = tangent.multiplyScalar(tangentialImpulseMagnitude); v1.add(tangentialImpulse.clone().multiplyScalar(1 / m1)); v2.sub(tangentialImpulse.clone().multiplyScalar(1 / m2)); } if (COLLISION_SPIN_LOSS_FACTOR > 0) { const spinLossMagnitude = Math.abs(j) * COLLISION_SPIN_LOSS_FACTOR; playerBeyData.angularVelocity = Math.max(0, playerBeyData.angularVelocity - spinLossMagnitude / m1); aiBeyData.angularVelocity = Math.max(0, aiBeyData.angularVelocity - spinLossMagnitude / m2); } const impulse = collisionNormal.clone().multiplyScalar(j); v1.add(impulse.clone().multiplyScalar(1 / m1)); v2.sub(impulse.clone().multiplyScalar(1 / m2)); if (v1.length() > MAX_VELOCITY) v1.setLength(MAX_VELOCITY); if (v2.length() > MAX_VELOCITY) v2.setLength(MAX_VELOCITY); const overlap = combinedRadius - Math.sqrt(distSq); if (overlap > 0) { const separationNormal = pos1.clone().sub(pos2).setY(0).normalize(); const correctionScale = Math.max(0.51, Math.min(0.8, overlap * 0.5)); const correction = separationNormal.multiplyScalar(overlap * correctionScale); pos1.add(correction); pos2.sub(correction); pos1.y = playerGroundY; pos2.y = aiGroundY; } }
        }

        // --- Win Conditions & End Game ---
        function checkWinConditions() {
            let winner = null; let loser = null; let reason = ""; if (playerBeyData.isOut && !aiBeyData.isOut) { winner = aiBeyData.type.name; loser = playerBeyData.type.name; reason = "Ë¢´ÊâìÂá∫Áïå"; } else if (aiBeyData.isOut && !playerBeyData.isOut) { winner = playerBeyData.type.name; loser = aiBeyData.type.name; reason = "Ë¢´ÊâìÂá∫Áïå"; } const playerSpinning = playerBeyData.angularVelocity > 0 && !playerBeyData.isOut; const aiSpinning = aiBeyData.angularVelocity > 0 && !aiBeyData.isOut; if (!winner) { if (!playerSpinning && aiSpinning) { winner = aiBeyData.type.name; loser = playerBeyData.type.name; reason = "ÂÅúÊ≠¢ÊóãËΩâ"; } else if (!aiSpinning && playerSpinning) { winner = playerBeyData.type.name; loser = aiBeyData.type.name; reason = "ÂÅúÊ≠¢ÊóãËΩâ"; } else if (!playerSpinning && !aiSpinning && !playerBeyData.isOut && !aiBeyData.isOut) { winner = "Âπ≥Êâã"; reason = "ÈõôÊñπÂÅúÊ≠¢ÊóãËΩâ"; } } if (playerBeyData.isOut && aiBeyData.isOut) { winner = "Âπ≥Êâã"; reason = "ÈõôÊñπÈÉΩË¢´ÊâìÂá∫Áïå"; } if (winner && (gameState === 'fighting' || gameState === 'launching')) { endGame(winner, loser, reason); }
        }
        function endGame(winner, loser, reason) {
             if (gameState === 'gameOver') return; gameState = 'gameOver'; if(chargeBarContainer) chargeBarContainer.style.display = 'none'; let message = ""; if (winner === "Âπ≥Êâã") { message = `Âπ≥Êâã! (${reason})`; } else { if (winner === playerBeyData.type.name) { message = `ÊÅ≠Âñú ${playerBeyData.type.name} Áç≤Âãù! (AI ${loser} ${reason})`; } else { message = `‰Ω†Ëº∏‰∫Ü! AI ${aiBeyData.type.name} Áç≤Âãù! (${playerBeyData.type.name} ${reason})`; } } gameUi.textContent = message; gameUi.style.display = 'block'; setTimeout(() => { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } selectedPlayerTypeId = null; document.querySelectorAll('.bey-card').forEach(c => c.classList.remove('selected')); if(startButton) { startButton.disabled = true; startButton.style.display = 'none'; } selectionScreen.style.display = 'flex'; gameContainer.style.display = 'none'; gameUi.style.display = 'none'; resetBattle(); }, 4000);
        }

        // --- Window Resize ---
        function onWindowResize() {
            if (!camera || !renderer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); updateArenaSizeAndDependents();
        }

        // --- Start ---
        init();
    </script>

</body>
</html>
