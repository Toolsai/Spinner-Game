<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Êà∞È¨•ÈôÄËû∫3D - ÊóãËΩâËÉΩÈáèÈ°ØÁ§∫Áâà</title>
    <style>
        /* Ê®£Âºè‰øùÊåÅ‰∏çËÆä */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #282c34; }
        #selection-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #0f3c57, #471391); color: #ecf0f1; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; z-index: 10; padding: 10px; box-sizing: border-box; overflow-y: auto; }
        #selection-screen h2 { margin: 15px 0; font-size: clamp(1.5em, 5vw, 2.5em); text-shadow: 2px 2px 5px rgba(0,0,0,0.5); color: #e0e0e0; }
        #beyblade-options { display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; max-width: 800px; padding: 10px; }
        .bey-card { position: relative; width: clamp(280px, 90vw, 350px); height: 150px; min-height: 130px; border-radius: 12px; margin: 5px; cursor: pointer; background-color: #34495e; box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.4); border: 3px solid transparent; transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease; display: flex; flex-direction: column; }
        .bey-card:hover { transform: translateY(-10px) scale(1.03); box-shadow: 8px 12px 20px rgba(0, 0, 0, 0.5); }
        .bey-card .bey-preview { height: 60%; width: 100%; display: flex; justify-content: center; align-items: center; position: relative; }
         .bey-card .bey-symbol { font-size: 3.5em; color: rgba(255, 255, 255, 0.2); text-shadow: 2px 2px 5px rgba(0,0,0,0.4); z-index: 2; }
         .bey-card .bey-info { height: 40%; padding: 10px; box-sizing: border-box; background-color: rgba(0, 0, 0, 0.4); color: #ecf0f1; display: flex; flex-direction: column; justify-content: center; position: relative; z-index: 3; }
          .bey-card .bey-name { font-weight: bold; font-size: 1.1em; margin-bottom: 5px; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); }
          .bey-card .bey-stats { font-size: 0.85em; line-height: 1.3; color: #bdc3c7; }
        .bey-card.selected { border-color: #2ecc71; transform: translateY(-5px) scale(1.05); box-shadow: 0 0 25px rgba(46, 204, 113, 0.7); }
        #start-button { margin-top: 40px; padding: 15px 40px; font-size: 1.6em; cursor: pointer; background: linear-gradient(145deg, #2e60cc, #6d27ae); color: white; border: none; border-radius: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); transition: background 0.2s ease, transform 0.1s ease; display: none; }
        #start-button:hover { background: linear-gradient(145deg, #e33f3f, #2ebb69); }
        #start-button:active { transform: scale(0.97); }
        #start-button:disabled { background: #7f8c8d; cursor: not-allowed; opacity: 0.6; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; cursor: pointer; }
        #game-ui { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); font-size: clamp(1em, 4vw, 1.6em); color: white; background-color: rgba(44, 62, 80, 0.7); padding: 8px 15px; border-radius: 8px; z-index: 6; text-shadow: 1px 1px 3px rgba(0,0,0,0.7); display: none; pointer-events: none; text-align: center; width: 90%; max-width: 500px; margin: 0 auto; }
        #charge-bar-container { position: absolute; bottom: 5%; left: 50%; transform: translateX(-50%); width: clamp(200px, 80%, 350px); height: 30px; background-color: rgba(0, 0, 0, 0.6); border: 2px solid #95a5a6; border-radius: 18px; z-index: 6; display: none; overflow: hidden; pointer-events: none; }
        #charge-bar-fill { width: 100%; height: 100%; background: linear-gradient(to right, #e74c3c, #f39c12, #2ecc71, #f39c12, #e74c3c); border-radius: 16px; }
        #charge-indicator { position: absolute; top: -2px; bottom: -2px; left: 0%; width: 6px; background-color: rgba(255, 255, 255, 0.9); border-radius: 3px; box-shadow: 0 0 5px rgba(255, 255, 255, 0.7); transform: translateX(-50%); transition: left 0.05s linear; }
        .spin-bar-container { position: absolute; top: 100px; width: clamp(120px, 35%, 400px); height: 25px; background-color: rgba(0, 0, 0, 0.5); border: 3px solid #7f8c8d; border-radius: 18px; z-index: 5; overflow: hidden; display: none; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .spin-bar-fill { height: 100%; width: 100%; border-radius: 11px; transition: width 0.15s linear; background-color: #e67e22; }
        .spin-bar-label { color: white; font-size: clamp(0.8em, 3vw, 1.2em); text-shadow: 2px 2px 3px black; position: absolute; top: 50%; transform: translateY(-50%); padding: 0 15px; z-index: 8; pointer-events: none; }
        #player-spin-bar-container { left: 10px; }
        #player-spin-bar-label { left: 0; }
        #ai-spin-bar-container { right: 10px; }
        #ai-spin-bar-label { right: 0; text-align: right;}
        @media screen and (max-width: 480px) { .bey-card { height: 85px; margin: 3px; } .bey-card .bey-symbol { font-size: 2.5em; } .bey-card .bey-name { font-size: 1em; } .bey-card .bey-stats { font-size: 0.75em; } #start-button { margin-top: 20px; padding: 10px 30px; font-size: 1.3em; } }
        @media screen and (max-width: 360px) { .spin-bar-container { height: 20px; } .spin-bar-label { padding: 0 8px; } #game-ui { padding: 6px 12px; } }
        @media screen and (orientation: landscape) and (max-height: 500px) { #selection-screen h2 { margin: 10px 0; } .bey-card { height: 80px; } #start-button { margin-top: 15px; } .spin-bar-container { top: 10px; } #charge-bar-container { bottom: 3%; } }
    </style>
</head>
<body>
    <div id="selection-screen"><h2>ÈÅ∏Êìá‰Ω†ÁöÑÈôÄËû∫</h2><div id="beyblade-options"></div><button id="start-button" disabled>ÈñãÂßãÈÅäÊà≤</button></div>
    <div id="game-container">
        <div id="player-spin-bar-container" class="spin-bar-container"><div id="player-spin-bar-fill" class="spin-bar-fill"></div><span id="player-spin-bar-label" class="spin-bar-label">Áé©ÂÆ∂</span></div>
        <div id="ai-spin-bar-container" class="spin-bar-container"><div id="ai-spin-bar-fill" class="spin-bar-fill"></div><span id="ai-spin-bar-label" class="spin-bar-label">AI</span></div>
        <div id="charge-bar-container"><div id="charge-bar-fill"></div><div id="charge-indicator"></div></div>
    </div>
    <div id="game-ui">Á≠âÂæÖÈñãÂßã...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- ÈÖçÁΩÆ ---
        const BEYBLADE_TYPES = [ { id: 'pegasus', name: 'Grok', symbol: '‚≠ê', color: 0x4488ff, colorHex: '#3160cb', weight: 1.0, initialSpeed: 0.15, stamina: 120 }, { id: 'l-drago', name: 'Gemini', symbol: 'üî•', color: 0xff4444, colorHex: '#8b3261', weight: 1.3, initialSpeed: 0.12, stamina: 110 }, { id: 'libra', name: 'Chat-GPT', symbol: '‚öñÔ∏è', color: 0x44ff44, colorHex: '#438b59', weight: 1.1, initialSpeed: 0.11, stamina: 130 } ];
        const ORIGINAL_ARENA_RADIUS = 13; const MIN_ARENA_RADIUS = 13; const MIN_REF_SCREEN_DIM = 360; const MAX_REF_SCREEN_DIM = 900; const BEYBLADE_RADIUS = 2;
        const GRAVITY_TOWARDS_CENTER = 0.0300; const FRICTION = 0.0010; const SPIN_FRICTION = 0.0150; const BOUNDARY_ENERGY_LOSS = 0.3; const COLLISION_ENERGY_LOSS = 0.25; const INTENSITY_MULTIPLIER = 1.9; const TANGENTIAL_KICK_FACTOR = 30; const COLLISION_SPIN_LOSS_FACTOR = 2.0; const MAX_VELOCITY = 0.6;
        const OBSTACLE_COLLISION_ENERGY_LOSS = 0.35; const OBSTACLE_SEPARATION_FORCE = 0.1; // Note: OBSTACLE_SEPARATION_FORCE is not used in the plane-based collision, position is corrected directly.
        const OBSTACLE_SPIN_LOSS_FACTOR = 6;
        const MIN_LAUNCH_POWER = 0.25; const INDICATOR_SPEED = 4.0;
        const SPARK_COUNT = 90; const SPARK_LIFESPAN = 0.45; const SPARK_SPEED_MIN = 15.0; const SPARK_SPEED_MAX = 35.0; const SPARK_BASE_SIZE = 5; const SPARK_COLOR = 0xff8c00; const SPARK_POOL_SIZE = 20; const SPARK_GRAVITY = -12.0;
        const OBSTACLE_BASE_WIDTH = BEYBLADE_RADIUS * 1.8; const OBSTACLE_HEIGHT = BEYBLADE_RADIUS * 2.3; const OBSTACLE_DEPTH = 3; const OBSTACLE_PLACEMENT_FACTOR = 0.8; const OBSTACLE_COLOR = 0x8866cc;
        const OBSTACLE_ROTATION_SPEED = Math.PI; // ÊØèÁßíÊóãËΩâÂçäÂúà

        let scene, camera, renderer; let arenaMesh, rimMesh;
        let obstacleGroup; // Group for obstacles
        let obstacleMeshes = []; // Array to hold individual obstacle meshes for collision checks
        let playerBeyData = { mesh: null, type: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0, maxStamina: 0 };
        let aiBeyData = { mesh: null, type: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0, maxStamina: 0 };
        let gameState = 'selecting'; let animationFrameId; let selectedPlayerTypeId = null; let launchInitiated = false; let indicatorPosition = 0; let indicatorDirection = 1; let captureIndicatorPosition = -1; let sparkPool = []; let sparkPoolIndex = 0; let sparkGeometry = null; let sparkTexture = null; let initialCameraDir = null; let arenaRadius = ORIGINAL_ARENA_RADIUS; let launchDistance = arenaRadius * 0.65;
        const materialsCache = {}; function getMaterial(color, options = {}) { const key = `${color}_${JSON.stringify(options)}`; if (!materialsCache[key]) { materialsCache[key] = new THREE.MeshStandardMaterial({ color, ...options }); } return materialsCache[key]; }
        const selectionScreen = document.getElementById('selection-screen'); const beybladeOptionsContainer = document.getElementById('beyblade-options'); const startButton = document.getElementById('start-button'); const gameContainer = document.getElementById('game-container'); const gameUi = document.getElementById('game-ui'); const chargeBarContainer = document.getElementById('charge-bar-container'); const chargeBarFill = document.getElementById('charge-bar-fill'); const chargeIndicator = document.getElementById('charge-indicator'); const playerSpinBarContainer = document.getElementById('player-spin-bar-container'); const playerSpinFill = document.getElementById('player-spin-bar-fill'); const playerSpinLabel = document.getElementById('player-spin-bar-label'); const aiSpinBarContainer = document.getElementById('ai-spin-bar-container'); const aiSpinFill = document.getElementById('ai-spin-bar-fill'); const aiSpinLabel = document.getElementById('ai-spin-bar-label');
        const clock = new THREE.Clock();

        // --- Physics Helper Variables ---
        const tempQuaternion = new THREE.Quaternion();
        const tempWorldPos = new THREE.Vector3(); // Temporary vector for world position
        const worldYAxisPhysics = new THREE.Vector3(0, 1, 0);
        const tempCollisionPoint = new THREE.Vector3(); // For spark position

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x231948);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, ORIGINAL_ARENA_RADIUS * 1.5, ORIGINAL_ARENA_RADIUS * 1.1); camera.lookAt(0, 0, 0); initialCameraDir = camera.position.clone().normalize();
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.outputEncoding = THREE.sRGBEncoding; gameContainer.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); directionalLight.position.set(10, 20, 15); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50; directionalLight.shadow.camera.left = -ORIGINAL_ARENA_RADIUS * 1.5; directionalLight.shadow.camera.right = ORIGINAL_ARENA_RADIUS * 1.5; directionalLight.shadow.camera.top = ORIGINAL_ARENA_RADIUS * 1.5; directionalLight.shadow.camera.bottom = -ORIGINAL_ARENA_RADIUS * 1.5; scene.add(directionalLight); const fillLight = new THREE.HemisphereLight(0x6060aa, 0x404088, 0.2); scene.add(fillLight);
            arenaRadius = ORIGINAL_ARENA_RADIUS; launchDistance = arenaRadius * 0.65;
            createArena(ORIGINAL_ARENA_RADIUS); initSparkSystem(); window.addEventListener('resize', onWindowResize, false); setupSelectionUI(); setupLaunchControls(); updateArenaSizeAndDependents();
        }

        function createArena(radiusToBuild = ORIGINAL_ARENA_RADIUS) {
            const floorGeometry = new THREE.CircleGeometry(radiusToBuild, 64); const floorMaterial = getMaterial(0xff6942, { metalness: 0.3, roughness: 0.6, side: THREE.DoubleSide }); arenaMesh = new THREE.Mesh(floorGeometry, floorMaterial); arenaMesh.rotation.x = -Math.PI / 2; arenaMesh.receiveShadow = true; scene.add(arenaMesh);
            const rimGeometry = new THREE.RingGeometry(radiusToBuild, radiusToBuild + 0.6, 64); const rimMaterial = getMaterial(0x454dc4, { metalness: 0.5, roughness: 0.4, side: THREE.DoubleSide }); rimMesh = new THREE.Mesh(rimGeometry, rimMaterial); rimMesh.rotation.x = -Math.PI / 2; rimMesh.position.y = 0.02; rimMesh.receiveShadow = true; scene.add(rimMesh);

            obstacleGroup = new THREE.Group();
            scene.add(obstacleGroup);

            const obstacleMaterial = getMaterial(OBSTACLE_COLOR, { metalness: 0.7, roughness: 0.5 });
            const triangleShape = new THREE.Shape(); const halfBase = OBSTACLE_BASE_WIDTH / 2;
            const centroidYOffset = OBSTACLE_HEIGHT / 3;
            triangleShape.moveTo(-halfBase, -centroidYOffset);
            triangleShape.lineTo(halfBase, -centroidYOffset);
            triangleShape.lineTo(0, OBSTACLE_HEIGHT * 2 / 3 - centroidYOffset);
            triangleShape.lineTo(-halfBase, -centroidYOffset);

            const extrudeSettings = { depth: OBSTACLE_DEPTH, bevelEnabled: false }; const obstacleGeometry = new THREE.ExtrudeGeometry(triangleShape, extrudeSettings); obstacleGeometry.computeVertexNormals();
            const placements = [
                { x: 0, z: radiusToBuild * OBSTACLE_PLACEMENT_FACTOR, rotZ: Math.PI, normal: new THREE.Vector3(0, 0, 1) }, // Top, points out (Normal along +Z in local space before rotation)
                { x: 0, z: -radiusToBuild * OBSTACLE_PLACEMENT_FACTOR, rotZ: 0, normal: new THREE.Vector3(0, 0, -1) },  // Bottom, points out (Normal along -Z)
                { x: radiusToBuild * OBSTACLE_PLACEMENT_FACTOR, z: 0, rotZ: Math.PI / 2, normal: new THREE.Vector3(1, 0, 0) }, // Right, points out (Normal along +X)
                { x: -radiusToBuild * OBSTACLE_PLACEMENT_FACTOR, z: 0, rotZ: -Math.PI / 2, normal: new THREE.Vector3(-1, 0, 0) } // Left, points out (Normal along -X)
            ];
            obstacleMeshes = [];
            placements.forEach((p) => {
                const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacleMesh.rotation.x = Math.PI / 2; // Lay flat
                obstacleMesh.position.set(p.x, OBSTACLE_DEPTH / 2, p.z); // Position relative to group center
                obstacleMesh.rotation.z = p.rotZ; // Orient the tip relative to group
                obstacleMesh.castShadow = true; obstacleMesh.receiveShadow = true;
                // Store the initial LOCAL face normal. We'll transform this to world space later.
                obstacleMesh.userData = { faceNormal: p.normal.clone() };
                obstacleGroup.add(obstacleMesh);
                obstacleMeshes.push(obstacleMesh); // Keep track for collision
            });
        }

        function updateArenaSizeAndDependents() {
            const currentMinScreenDim = Math.min(window.innerWidth, window.innerHeight); const screenRange = MAX_REF_SCREEN_DIM - MIN_REF_SCREEN_DIM; let scaleFactor = screenRange <= 0 ? 1.0 : Math.max(0, Math.min(1, (currentMinScreenDim - MIN_REF_SCREEN_DIM) / screenRange));
            const newRadius = MIN_ARENA_RADIUS + (ORIGINAL_ARENA_RADIUS - MIN_ARENA_RADIUS) * scaleFactor; arenaRadius = newRadius; launchDistance = arenaRadius * 0.65;
            const modelScale = arenaRadius / ORIGINAL_ARENA_RADIUS; if (arenaMesh) arenaMesh.scale.set(modelScale, 1, modelScale); if (rimMesh) rimMesh.scale.set(modelScale, 1, modelScale);

            if (obstacleGroup && obstacleMeshes.length > 0) {
                 // Calculate new placement radius based on the original placement factor and the *new* arena radius
                const newPlacementRadius = arenaRadius * OBSTACLE_PLACEMENT_FACTOR;
                const placements = [
                     { x: 0, z: newPlacementRadius}, // Top
                     { x: 0, z: -newPlacementRadius}, // Bottom
                     { x: newPlacementRadius, z: 0}, // Right
                     { x: -newPlacementRadius, z: 0} // Left
                ];
                obstacleMeshes.forEach((mesh, index) => {
                    mesh.position.x = placements[index].x;
                    mesh.position.z = placements[index].z;
                    // Optionally scale the obstacle mesh itself if desired
                    // mesh.scale.set(modelScale, 1, modelScale); // Scale depth? Probably not. Maybe width/height?
                });
            }

            if (!scene.fog) { scene.fog = new THREE.Fog(scene.background, arenaRadius * 2.5, arenaRadius * 5); } else { scene.fog.near = arenaRadius * 2.5; scene.fog.far = arenaRadius * 5; }
            adjustCameraToFitArena();
        }

        function adjustCameraToFitArena() {
            if (!camera || !initialCameraDir) return; const aspect = camera.aspect; const vFovRad = THREE.MathUtils.degToRad(camera.fov); const hFovRad = 2 * Math.atan(Math.tan(vFovRad / 2) * aspect); const margin = 1.15; const targetRadius = arenaRadius * margin; const distV = targetRadius / Math.tan(vFovRad / 2); const distH = targetRadius / Math.tan(hFovRad / 2); const requiredDistance = Math.max(distV, distH); camera.position.copy(initialCameraDir).multiplyScalar(requiredDistance); camera.lookAt(0, 0, 0);
        }

        function initSparkSystem() {
            sparkTexture = createSparkTexture(); sparkGeometry = new THREE.BufferGeometry(); const positions = new Float32Array(SPARK_COUNT * 3); const velocities = new Float32Array(SPARK_COUNT * 3); const startTimes = new Float32Array(SPARK_COUNT); const baseSizes = new Float32Array(SPARK_COUNT); sparkGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); sparkGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3)); sparkGeometry.setAttribute('startTime', new THREE.BufferAttribute(startTimes, 1)); sparkGeometry.setAttribute('baseSize', new THREE.BufferAttribute(baseSizes, 1)); const baseSparkMaterial = new THREE.PointsMaterial({ size: SPARK_BASE_SIZE, color: SPARK_COLOR, map: sparkTexture, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false, sizeAttenuation: true, opacity: 1.0 }); for (let i = 0; i < SPARK_POOL_SIZE; i++) { const materialClone = baseSparkMaterial.clone(); const points = new THREE.Points(sparkGeometry, materialClone); points.visible = false; points.userData = { isActive: false, activationTime: 0 }; sparkPool.push(points); scene.add(points); }
        }

        function createSparkTexture() { const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64; const context = canvas.getContext('2d'); const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32); gradient.addColorStop(0, 'rgba(255, 255, 220, 1)'); gradient.addColorStop(0.1, 'rgba(255, 200, 100, 1)'); gradient.addColorStop(0.4, 'rgba(255, 165, 0, 0.6)'); gradient.addColorStop(1, 'rgba(255, 140, 0, 0)'); context.fillStyle = gradient; context.fillRect(0, 0, 64, 64); const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; return texture; }

        function triggerSparks(position, intensity) { const points = sparkPool[sparkPoolIndex]; if (!points) return; const geometry = points.geometry; const attributes = geometry.attributes; if (!attributes.velocity || !attributes.startTime || !attributes.position || !attributes.baseSize) { console.error("ÁÅ´Ëä±Âπæ‰ΩïÈ´îÂ±¨ÊÄßÁº∫Â§±!"); return; } const velocities = attributes.velocity.array; const startTimes = attributes.startTime.array; const positions = attributes.position.array; const baseSizes = attributes.baseSize.array; points.position.copy(position); const currentTime = clock.elapsedTime; const intensityFactor = Math.min(1, Math.sqrt(intensity / 20)); const speedRange = SPARK_SPEED_MAX - SPARK_SPEED_MIN; for (let i = 0; i < SPARK_COUNT; i++) { const i3 = i * 3; const angle = Math.random() * Math.PI * 2; const heightFactor = Math.random() * 2 - 1; const radius = Math.random(); const dirX = Math.cos(angle) * radius; const dirY = Math.abs(heightFactor) + 0.2; const dirZ = Math.sin(angle) * radius; const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ); const speed = SPARK_SPEED_MIN + Math.random() * speedRange * intensityFactor; velocities[i3 + 0] = (dirX / length) * speed * (1 + Math.random() * 0.5); velocities[i3 + 1] = (dirY / length) * speed * (1 + Math.random() * 0.5); velocities[i3 + 2] = (dirZ / length) * speed * (1 + Math.random() * 0.5); positions[i3 + 0] = 0; positions[i3 + 1] = 0; positions[i3 + 2] = 0; startTimes[i] = currentTime; baseSizes[i] = SPARK_BASE_SIZE * (0.5 + Math.random()); } attributes.position.needsUpdate = true; attributes.velocity.needsUpdate = true; attributes.startTime.needsUpdate = true; attributes.baseSize.needsUpdate = true; points.material.opacity = 1.0; points.visible = true; points.userData.isActive = true; points.userData.activationTime = currentTime; sparkPoolIndex = (sparkPoolIndex + 1) % SPARK_POOL_SIZE; }

        function setupSelectionUI() { beybladeOptionsContainer.innerHTML = ''; if (!beybladeOptionsContainer) { console.error("Êâæ‰∏çÂà∞ ID ÁÇ∫ 'beyblade-options' ÁöÑÂÖÉÁ¥†!"); return; } BEYBLADE_TYPES.forEach(type => { const card = document.createElement('div'); card.classList.add('bey-card'); card.dataset.beyId = type.id; const previewArea = document.createElement('div'); previewArea.classList.add('bey-preview'); previewArea.style.background = `radial-gradient(ellipse at top, ${lightenColor(type.colorHex, 30)}, ${type.colorHex} 70%)`; const symbolSpan = document.createElement('span'); symbolSpan.classList.add('bey-symbol'); symbolSpan.textContent = type.symbol || 'üåÄ'; previewArea.appendChild(symbolSpan); card.appendChild(previewArea); const infoDiv = document.createElement('div'); infoDiv.classList.add('bey-info'); infoDiv.innerHTML = `<div class="bey-name">${type.name}</div><div class="bey-stats">È´îÈáç: ${type.weight.toFixed(1)} | ÈÄüÂ∫¶: ${type.initialSpeed.toFixed(2)} | ËÄêÂäõ: ${type.stamina}</div>`; card.appendChild(infoDiv); card.addEventListener('click', () => { document.querySelectorAll('.bey-card').forEach(c => c.classList.remove('selected')); card.classList.add('selected'); selectedPlayerTypeId = type.id; if(startButton) { startButton.disabled = false; startButton.style.display = 'inline-block'; } }); beybladeOptionsContainer.appendChild(card); }); if(startButton) startButton.addEventListener('click', startGame); }

        function lightenColor(hex, percent) { hex = hex.replace(/^#/, ''); const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); const newR = Math.min(255, r + Math.floor(255 * (percent / 100))); const newG = Math.min(255, g + Math.floor(255 * (percent / 100))); const newB = Math.min(255, b + Math.floor(255 * (percent / 100))); return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`; }

        function startGame() { if (!selectedPlayerTypeId) return; gameState = 'preparing'; launchInitiated = false; captureIndicatorPosition = -1; indicatorPosition = Math.random(); indicatorDirection = Math.random() < 0.5 ? 1 : -1; selectionScreen.style.display = 'none'; gameContainer.style.display = 'block'; gameUi.style.display = 'block'; gameUi.textContent = "Ê∫ñÂÇôÁôºÂ∞Ñ..."; playerBeyData.type = BEYBLADE_TYPES.find(b => b.id === selectedPlayerTypeId); const availableAiTypes = BEYBLADE_TYPES.filter(b => b.id !== selectedPlayerTypeId); aiBeyData.type = availableAiTypes[Math.floor(Math.random() * availableAiTypes.length)]; playerBeyData.maxStamina = playerBeyData.type.stamina; aiBeyData.maxStamina = aiBeyData.type.stamina; resetBattle(); setupBattle(); if (playerSpinBarContainer) playerSpinBarContainer.style.display = 'block'; if (aiSpinBarContainer) aiSpinBarContainer.style.display = 'block'; if (playerSpinFill) { playerSpinFill.style.width = '100%'; playerSpinFill.style.backgroundColor = playerBeyData.type.colorHex; playerSpinLabel.textContent = playerBeyData.type.name; } if (aiSpinFill) { aiSpinFill.style.width = '100%'; aiSpinFill.style.backgroundColor = aiBeyData.type.colorHex; aiSpinLabel.textContent = aiBeyData.type.name; } setTimeout(() => { gameState = 'launching'; if(chargeBarContainer) chargeBarContainer.style.display = 'block'; if(chargeIndicator) chargeIndicator.style.left = `${indicatorPosition * 100}%`; gameUi.textContent = "ÈªûÊìäËû¢ÂπïÁôºÂ∞Ñ!"; if (!animationFrameId) { animate(); } }, 500); }

        function setupLaunchControls() { if(gameContainer) gameContainer.addEventListener('pointerdown', captureLaunchTiming); }
        function captureLaunchTiming(event) { if (gameState === 'launching' && !launchInitiated) { event.preventDefault(); captureIndicatorPosition = indicatorPosition; initiateLaunch(); } }
        function initiateLaunch() { if (launchInitiated || captureIndicatorPosition < 0) return; launchInitiated = true; if(chargeBarContainer) chargeBarContainer.style.display = 'none'; const deviation = Math.abs(captureIndicatorPosition - 0.5); const timedPower = 1.0 - deviation * 2; const launchPowerFactor = MIN_LAUNCH_POWER + timedPower * (1.0 - MIN_LAUNCH_POWER); playerBeyData.angularVelocity = playerBeyData.maxStamina * launchPowerFactor; const aiLaunchPowerFactor = MIN_LAUNCH_POWER + Math.random() * (1.0 - MIN_LAUNCH_POWER); aiBeyData.angularVelocity = aiBeyData.maxStamina * aiLaunchPowerFactor; playerBeyData.velocity.set(launchDistance * 0.8, 0, (Math.random() - 0.5) * launchDistance * 0.8).normalize().multiplyScalar(playerBeyData.type.initialSpeed * (0.8 + launchPowerFactor * 0.4)); aiBeyData.velocity.set(-launchDistance * 0.8, 0, (Math.random() - 0.5) * launchDistance * 0.8).normalize().multiplyScalar(aiBeyData.type.initialSpeed * (0.8 + aiLaunchPowerFactor * 0.4)); gameUi.textContent = "Â∞çÊà∞ÈñãÂßã!"; setTimeout(() => { if (gameState === 'launching') gameState = 'fighting'; }, 100); }
        function resetBattle() { if (playerBeyData.mesh) scene.remove(playerBeyData.mesh); if (aiBeyData.mesh) scene.remove(aiBeyData.mesh); playerBeyData = { ...playerBeyData, mesh: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0 }; aiBeyData = { ...aiBeyData, mesh: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0 }; sparkPool.forEach(points => { if (points.userData.isActive) { points.visible = false; points.userData.isActive = false; points.material.opacity = 1.0; } }); sparkPoolIndex = 0; if (playerSpinBarContainer) playerSpinBarContainer.style.display = 'none'; if (aiSpinBarContainer) aiSpinBarContainer.style.display = 'none'; }
        function createBeybladeMesh(beyType) { const group = new THREE.Group(); const radius = BEYBLADE_RADIUS; const mainHeight = radius * 0.6; const detailHeight = radius * 0.4; const mainMat = getMaterial(beyType.color, { metalness: 0.5, roughness: 0.4 }); const metalMat = getMaterial(0xcccccc, { metalness: 0.8, roughness: 0.3 }); const darkMetalMat = getMaterial(0x555555, { metalness: 0.7, roughness: 0.4 }); const accentMat = getMaterial(0xffff00, { metalness: 0.6, roughness: 0.4 }); let lowestY = 0; switch (beyType.id) { case 'pegasus': { const bodyGeo = new THREE.CylinderGeometry(radius * 0.8, radius * 0.5, mainHeight, 16); const bodyMesh = new THREE.Mesh(bodyGeo, mainMat); bodyMesh.position.y = detailHeight + mainHeight / 2; bodyMesh.castShadow = true; group.add(bodyMesh); const ringGeo = new THREE.TorusGeometry(radius * 0.9, radius * 0.15, 8, 32); const ringMesh = new THREE.Mesh(ringGeo, metalMat); ringMesh.rotation.x = Math.PI / 2; ringMesh.position.y = detailHeight * 0.8; ringMesh.castShadow = true; group.add(ringMesh); const baseGeo = new THREE.ConeGeometry(radius * 0.6, detailHeight, 16); const baseMesh = new THREE.Mesh(baseGeo, metalMat); baseMesh.position.y = detailHeight / 2; baseMesh.castShadow = true; group.add(baseMesh); lowestY = 0; break; } case 'l-drago': { const bodyGeo = new THREE.ConeGeometry(radius * 0.7, mainHeight * 1.2, 16); const bodyMesh = new THREE.Mesh(bodyGeo, mainMat); bodyMesh.position.y = detailHeight + mainHeight * 0.6; bodyMesh.castShadow = true; group.add(bodyMesh); const wheelGeo = new THREE.CylinderGeometry(radius * 1.0, radius * 0.9, detailHeight * 0.8, 16); const wheelMesh = new THREE.Mesh(wheelGeo, darkMetalMat); wheelMesh.position.y = detailHeight * 0.6; wheelMesh.castShadow = true; group.add(wheelMesh); const baseGeo = new THREE.CylinderGeometry(radius * 0.4, radius * 0.2, detailHeight * 0.4, 16); const baseMesh = new THREE.Mesh(baseGeo, darkMetalMat); baseMesh.position.y = detailHeight * 0.2; baseMesh.castShadow = true; group.add(baseMesh); lowestY = 0; break; } case 'libra': default: { const bodyGeo = new THREE.CylinderGeometry(radius * 0.95, radius * 0.85, mainHeight * 0.6, 24); const bodyMesh = new THREE.Mesh(bodyGeo, mainMat); bodyMesh.position.y = detailHeight + (mainHeight * 0.6) / 2; bodyMesh.castShadow = true; group.add(bodyMesh); const ringGeo = new THREE.TorusGeometry(radius * 0.8, radius * 0.18, 8, 32); const ringMesh = new THREE.Mesh(ringGeo, metalMat); ringMesh.rotation.x = Math.PI / 2; ringMesh.position.y = detailHeight * 0.7; ringMesh.castShadow = true; group.add(ringMesh); const baseTopGeo = new THREE.CylinderGeometry(radius * 0.6, radius * 0.7, detailHeight * 0.4, 16); const baseTopMesh = new THREE.Mesh(baseTopGeo, accentMat); baseTopMesh.position.y = detailHeight * 0.6; baseTopMesh.castShadow = true; group.add(baseTopMesh); const baseBottomGeo = new THREE.CylinderGeometry(radius * 0.7, radius * 0.5, detailHeight * 0.4, 16); const baseBottomMesh = new THREE.Mesh(baseBottomGeo, accentMat); baseBottomMesh.position.y = detailHeight * 0.2; baseBottomMesh.castShadow = true; group.add(baseBottomMesh); lowestY = 0; break; } } group.position.y = -lowestY; const meshBaseOffset = -lowestY; return { mesh: group, baseOffset: meshBaseOffset }; }
        function setupBattle() { const playerResult = createBeybladeMesh(playerBeyData.type); playerBeyData.mesh = playerResult.mesh; playerBeyData.baseOffset = playerResult.baseOffset; playerBeyData.mesh.position.set(-launchDistance, playerBeyData.baseOffset, (Math.random() - 0.5) * 4); scene.add(playerBeyData.mesh); const aiResult = createBeybladeMesh(aiBeyData.type); aiBeyData.mesh = aiResult.mesh; aiBeyData.baseOffset = aiResult.baseOffset; aiBeyData.mesh.position.set(launchDistance, aiBeyData.baseOffset, (Math.random() - 0.5) * 4); scene.add(aiBeyData.mesh); }

        function animate() {
            animationFrameId = requestAnimationFrame(animate); const delta = clock.getDelta(); const currentTime = clock.elapsedTime;
            if (gameState === 'launching' && !launchInitiated) { indicatorPosition += indicatorDirection * INDICATOR_SPEED * delta; if (indicatorPosition >= 1.0) { indicatorPosition = 1.0; indicatorDirection = -1; } else if (indicatorPosition <= 0.0) { indicatorPosition = 0.0; indicatorDirection = 1; } if (chargeIndicator) { chargeIndicator.style.left = `${indicatorPosition * 100}%`; } }

            // Rotate obstacle group
            if (obstacleGroup && (gameState === 'fighting' || gameState === 'launching' || gameState === 'preparing')) {
                obstacleGroup.rotation.y += OBSTACLE_ROTATION_SPEED * delta;
            }

            // Update game state
            if (gameState === 'fighting') {
                 updatePhysics(playerBeyData, delta);
                 updatePhysics(aiBeyData, delta);
                 handleCollisions(delta); // Beyblade vs Beyblade
                 checkWinConditions();
                 const playerSpinPercent = Math.max(0, Math.min(100, (playerBeyData.angularVelocity / playerBeyData.maxStamina) * 100));
                 const aiSpinPercent = Math.max(0, Math.min(100, (aiBeyData.angularVelocity / aiBeyData.maxStamina) * 100));
                 if (playerSpinFill) playerSpinFill.style.width = playerSpinPercent + '%';
                 if (aiSpinFill) aiSpinFill.style.width = aiSpinPercent + '%';
            }

            // Update sparks
            sparkPool.forEach(points => { if (points.userData.isActive) { const activationTime = points.userData.activationTime; const elapsedTime = currentTime - activationTime; const lifeRatio = Math.min(1.0, elapsedTime / SPARK_LIFESPAN); if (lifeRatio >= 1.0) { points.visible = false; points.userData.isActive = false; } else { points.material.opacity = Math.pow(1.0 - lifeRatio, 1.5); points.material.size = SPARK_BASE_SIZE * (1.0 - lifeRatio * 0.8); const geometry = points.geometry; const attributes = geometry.attributes; const positions = attributes.position.array; const velocities = attributes.velocity.array; const startTimes = attributes.startTime.array; let needsPosUpdate = false; for (let i = 0; i < SPARK_COUNT; i++) { if (startTimes[i] === activationTime) { const i3 = i * 3; const particleElapsedTime = currentTime - startTimes[i]; positions[i3 + 0] = velocities[i3 + 0] * particleElapsedTime; positions[i3 + 1] = velocities[i3 + 1] * particleElapsedTime + 0.5 * SPARK_GRAVITY * particleElapsedTime * particleElapsedTime; positions[i3 + 2] = velocities[i3 + 2] * particleElapsedTime; needsPosUpdate = true; } } if(needsPosUpdate) { attributes.position.needsUpdate = true; } } } });

            // Render scene
            renderer.render(scene, camera);
        }


        // --- THIS IS THE CORRECTED updatePhysics FUNCTION ---
        function updatePhysics(beyData, delta) {
            const groundY = beyData.baseOffset;
            if (!beyData.mesh || beyData.isOut || beyData.angularVelocity <= 0) {
                if (beyData.angularVelocity <= 0 && !beyData.isOut && beyData.mesh) {
                    beyData.velocity.set(0, 0, 0);
                    if (beyData.mesh.position.y !== groundY) beyData.mesh.position.y = groundY;
                }
                return;
            }

            const mesh = beyData.mesh;
            const velocity = beyData.velocity;
            const type = beyData.type;
            const beyRadius = BEYBLADE_RADIUS; // Use constant

            // Apply friction and spin drain
            const frictionFactor = Math.pow(1.0 - FRICTION, delta * 60);
            velocity.multiplyScalar(frictionFactor);
            const spinDrainMultiplier = Math.max(0.6, (2.2 - type.stamina / 100));
            beyData.angularVelocity -= SPIN_FRICTION * spinDrainMultiplier * delta * 60;
            beyData.angularVelocity = Math.max(0, beyData.angularVelocity);

            // Apply gravity towards center
            if (GRAVITY_TOWARDS_CENTER > 0) {
                const centerPull = mesh.position.clone().setY(0).negate();
                const distFromCenter = centerPull.length();
                const randomAngle = Math.random() * Math.PI * 2;
                const randomOffset = new THREE.Vector3(Math.cos(randomAngle), 0, Math.sin(randomAngle));
                const centerInfluence = Math.min(1.0, distFromCenter / (arenaRadius * 0.8));
                const randomInfluence = 1 - centerInfluence;
                centerPull.normalize();
                const finalDirection = centerPull.multiplyScalar(centerInfluence).add(randomOffset.multiplyScalar(randomInfluence)).normalize();
                const pullStrength = GRAVITY_TOWARDS_CENTER * (0.8 + Math.random() * 0.4);
                velocity.add(finalDirection.multiplyScalar(pullStrength * delta * 60 / type.weight));
            }

            // --- Update Position FIRST ---
            mesh.position.addScaledVector(velocity, delta * 60);

            // --- Collision Detection & Response ---
            let hitObstacle = false;
            const beyPos = mesh.position; // Use the updated position for checks

            for (const obstacle of obstacleMeshes) {
                // Get obstacle's current world state
                obstacle.getWorldPosition(tempWorldPos);
                obstacle.getWorldQuaternion(tempQuaternion);
                // Transform the obstacle's local face normal into world space
                const currentCollisionNormal = obstacle.userData.faceNormal.clone().applyQuaternion(tempQuaternion).normalize();

                // --- Precise Collision Check using Plane Distance ---
                // Vector from a point on the plane (obstacle world pos) to the Beyblade center
                const vecFromPlanePointToBey = beyPos.clone().sub(tempWorldPos);
                // Signed distance from Beyblade center to the infinite plane defined by the obstacle face
                const distToPlane = vecFromPlanePointToBey.dot(currentCollisionNormal);

                // Quick check: Is the Beyblade sphere potentially intersecting the plane?
                if (Math.abs(distToPlane) < beyRadius) {
                    // Check if Beyblade was moving towards the obstacle face
                    const velAlongNormal = velocity.dot(currentCollisionNormal);

                    if (velAlongNormal < -0.001) { // Moving towards the face (negative dot product), added tolerance
                        // --- COLLISION OCCURRED ---
                        hitObstacle = true;

                        // 1. Calculate Penetration Depth
                        const overlap = beyRadius - distToPlane; // Positive overlap means penetration

                        // 2. Correct Position Immediately to resolve penetration
                        // Move back along the normal by the overlap distance if penetration occurred
                        if (overlap > 0) {
                           mesh.position.addScaledVector(currentCollisionNormal, overlap);
                        }

                        // 3. Reflect Velocity according to the Law of Reflection
                        velocity.reflect(currentCollisionNormal);

                        // 4. Apply Energy Loss (Coefficient of Restitution)
                        const energyLoss = OBSTACLE_COLLISION_ENERGY_LOSS * (0.8 + Math.random() * 0.4);
                        velocity.multiplyScalar(1.0 - energyLoss);

                        // 5. Apply Spin Loss based on impact speed along normal
                        const impactSpeed = Math.abs(velAlongNormal); // Speed component perpendicular to the surface before bounce
                        const spinLossAmount = (impactSpeed * OBSTACLE_SPIN_LOSS_FACTOR) / type.weight;
                        beyData.angularVelocity = Math.max(0, beyData.angularVelocity - spinLossAmount);

                        // 6. Trigger Sparks near the collision point
                        // Approximate collision point on the plane
                        tempCollisionPoint.copy(beyPos).addScaledVector(currentCollisionNormal, -distToPlane); // Project original center onto plane
                        tempCollisionPoint.y = groundY + beyRadius * 0.3; // Raise sparks slightly
                        const sparkIntensity = impactSpeed * 45 + 15;
                        triggerSparks(tempCollisionPoint, sparkIntensity);

                        // Process only one obstacle collision per Beyblade per frame
                        break;
                    }
                }
            } // End obstacle loop

            // --- Boundary Collision (Arena Edge) ---
            // Check *after* obstacle collision response
            if (!hitObstacle) {
                const distanceFromCenter = mesh.position.clone().setY(0).length();
                const boundaryRadius = arenaRadius - beyRadius; // Use beyRadius
                if (distanceFromCenter > boundaryRadius) {
                    // Calculate normal pointing inwards from boundary
                    const normal = mesh.position.clone().setY(0).normalize().negate();
                    const velocityBeforeBounce = velocity.clone(); // Store pre-bounce velocity

                    // Deflect slightly randomly off the wall normal
                    const deflectionAngle = (Math.random() - 0.5) * Math.PI * 0.6;
                    normal.applyAxisAngle(worldYAxisPhysics, deflectionAngle);

                    // Reflect velocity
                    velocity.reflect(normal);

                    // Apply boundary energy loss
                    const energyLoss = BOUNDARY_ENERGY_LOSS * (0.8 + Math.random() * 0.4);
                    velocity.multiplyScalar(1.0 - energyLoss);

                    // Calculate impact speed for sparks (use absolute dot product before reflect)
                    const impactSpeed = Math.abs(velocityBeforeBounce.dot(normal.clone().negate()));
                    const sparkIntensity = impactSpeed * 35 + 10;

                    // Correct position to be just inside boundary
                    // Use the original inwards normal for correction direction
                    const correctionDir = mesh.position.clone().setY(0).normalize();
                    mesh.position.x = correctionDir.x * boundaryRadius;
                    mesh.position.z = correctionDir.z * boundaryRadius;

                    // Trigger sparks at boundary contact point (use corrected position)
                    const sparkPosition = mesh.position.clone();
                    sparkPosition.y = groundY + beyRadius * 0.3;
                    triggerSparks(sparkPosition, sparkIntensity);
                }
            }

            // Ensure Beyblade stays on the ground plane
            mesh.position.y = groundY;

            // Clamp velocity if needed
            if (velocity.lengthSq() > MAX_VELOCITY * MAX_VELOCITY) {
                velocity.setLength(MAX_VELOCITY);
            }
        }
        // --- END OF CORRECTED updatePhysics ---


        // handleCollisions (Beyblade vs Beyblade - unchanged)
        function handleCollisions(delta) {
             if (!playerBeyData.mesh || !aiBeyData.mesh || playerBeyData.isOut || aiBeyData.isOut || gameState !== 'fighting') return;
             const playerGroundY = playerBeyData.baseOffset; const aiGroundY = aiBeyData.baseOffset;
             const pos1 = playerBeyData.mesh.position; const pos2 = aiBeyData.mesh.position;
             const pos1_xz = new THREE.Vector2(pos1.x, pos1.z); const pos2_xz = new THREE.Vector2(pos2.x, pos2.z);
             const distSq = pos1_xz.distanceToSquared(pos2_xz); const combinedRadius = BEYBLADE_RADIUS * 2;
             if (distSq < combinedRadius * combinedRadius && distSq > 0.0001) {
                 const v1 = playerBeyData.velocity; const v2 = aiBeyData.velocity;
                 const m1 = playerBeyData.type.weight; const m2 = aiBeyData.type.weight;
                 const collisionNormal = pos1.clone().sub(pos2).setY(0).normalize();
                 const relativeVelocity = v1.clone().sub(v2);
                 const velAlongNormal = relativeVelocity.dot(collisionNormal);
                 if (velAlongNormal > 0) return; // Moving apart
                 const restitution = 1.0 - COLLISION_ENERGY_LOSS;
                 let j = -(1 + restitution) * velAlongNormal; j /= (1 / m1) + (1 / m2); j *= INTENSITY_MULTIPLIER;
                 const collisionIntensity = Math.abs(j) * 1.0 + 5;
                 const sparkPos1 = pos1.clone(); sparkPos1.y += BEYBLADE_RADIUS * 0.2; triggerSparks(sparkPos1, collisionIntensity);
                 const sparkPos2 = pos2.clone(); sparkPos2.y += BEYBLADE_RADIUS * 0.2; triggerSparks(sparkPos2, collisionIntensity);
                 if (TANGENTIAL_KICK_FACTOR > 0) {
                     let tangent = new THREE.Vector3(-collisionNormal.z, 0, collisionNormal.x).normalize();
                     const spinDiff = playerBeyData.angularVelocity - aiBeyData.angularVelocity;
                     if (spinDiff < 0) { tangent.multiplyScalar(-1); }
                     const randomAngle = (Math.random() - 0.5) * Math.PI * 0.5; tangent.applyAxisAngle(worldYAxisPhysics, randomAngle);
                     const spinFactor = Math.abs(spinDiff) / Math.max(playerBeyData.maxStamina, aiBeyData.maxStamina);
                     const tangentialImpulseMagnitude = Math.abs(j) * TANGENTIAL_KICK_FACTOR * (1 + spinFactor);
                     const tangentialImpulse = tangent.multiplyScalar(tangentialImpulseMagnitude);
                     v1.add(tangentialImpulse.clone().multiplyScalar(1 / m1)); v2.sub(tangentialImpulse.clone().multiplyScalar(1 / m2));
                 }
                 if (COLLISION_SPIN_LOSS_FACTOR > 0) {
                     const spinLossMagnitude = Math.abs(j) * COLLISION_SPIN_LOSS_FACTOR;
                     playerBeyData.angularVelocity = Math.max(0, playerBeyData.angularVelocity - spinLossMagnitude / m1);
                     aiBeyData.angularVelocity = Math.max(0, aiBeyData.angularVelocity - spinLossMagnitude / m2);
                 }
                 const impulse = collisionNormal.clone().multiplyScalar(j);
                 v1.add(impulse.clone().multiplyScalar(1 / m1)); v2.sub(impulse.clone().multiplyScalar(1 / m2));
                 if (v1.length() > MAX_VELOCITY) v1.setLength(MAX_VELOCITY);
                 if (v2.length() > MAX_VELOCITY) v2.setLength(MAX_VELOCITY);
                 const overlap = combinedRadius - Math.sqrt(distSq);
                 if (overlap > 0) {
                     const separationNormal = pos1.clone().sub(pos2).setY(0).normalize();
                     const correctionScale = Math.max(0.51, Math.min(0.8, overlap * 0.5));
                     const correction = separationNormal.multiplyScalar(overlap * correctionScale);
                     pos1.add(correction); pos2.sub(correction); pos1.y = playerGroundY; pos2.y = aiGroundY;
                 }
            }
        }

        // checkWinConditions (unchanged)
        function checkWinConditions() {
             let winner = null; let loser = null; let reason = "";
             const playerSpinning = playerBeyData.angularVelocity > 0 && !playerBeyData.isOut;
             const aiSpinning = aiBeyData.angularVelocity > 0 && !aiBeyData.isOut;
             if (!winner) {
                 if (!playerSpinning && aiSpinning) { winner = aiBeyData.type.name; loser = playerBeyData.type.name; reason = "ÂÅúÊ≠¢ÊóãËΩâ"; }
                 else if (!aiSpinning && playerSpinning) { winner = playerBeyData.type.name; loser = aiBeyData.type.name; reason = "ÂÅúÊ≠¢ÊóãËΩâ"; }
                 else if (!playerSpinning && !aiSpinning && !playerBeyData.isOut && !aiBeyData.isOut) { winner = "Âπ≥Êâã"; reason = "ÈõôÊñπÂÅúÊ≠¢ÊóãËΩâ"; }
             }
             if (winner && (gameState === 'fighting' || gameState === 'launching')) { endGame(winner, loser, reason); }
        }

        // endGame (unchanged)
        function endGame(winner, loser, reason) {
             if (gameState === 'gameOver') return;
             gameState = 'gameOver';
             if(chargeBarContainer) chargeBarContainer.style.display = 'none';
             let message = "";
             if (winner === "Âπ≥Êâã") { message = `Âπ≥Êâã! (${reason})`; }
             else { if (winner === playerBeyData.type.name) { message = `ÊÅ≠Âñú ${playerBeyData.type.name} Áç≤Âãù! (AI ${loser} ${reason})`; }
             else { message = `‰Ω†Ëº∏‰∫Ü! AI ${aiBeyData.type.name} Áç≤Âãù! (${playerBeyData.type.name} ${reason})`; } }
             gameUi.textContent = message; gameUi.style.display = 'block';
             setTimeout(() => {
                 if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                 selectedPlayerTypeId = null;
                 document.querySelectorAll('.bey-card').forEach(c => c.classList.remove('selected'));
                 if(startButton) { startButton.disabled = true; startButton.style.display = 'none'; }
                 selectionScreen.style.display = 'flex';
                 gameContainer.style.display = 'none';
                 gameUi.style.display = 'none';
                 resetBattle();
                 // Make sure obstacle group rotation stops or resets if needed
                 if(obstacleGroup) obstacleGroup.rotation.y = 0;
             }, 4000);
        }

        // onWindowResize (unchanged)
        function onWindowResize() {
             if (!camera || !renderer) return;
             camera.aspect = window.innerWidth / window.innerHeight;
             camera.updateProjectionMatrix();
             renderer.setSize(window.innerWidth, window.innerHeight);
             updateArenaSizeAndDependents(); // This will handle resizing arena and obstacle positions
        }

        // Initialize the application
        init();
    </script>

</body>
</html>
