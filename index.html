<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> {/* Added user-scalable=no */}
    <title>Êà∞È¨•ÈôÄËû∫3D - ÊóãËΩâËÉΩÈáèÈ°ØÁ§∫Áâà</title>
    <style>
        /* Styles remain the same */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #282c34; }
        #selection-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #0f3c57, #471391); color: #ecf0f1; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; z-index: 10; padding: 10px; box-sizing: border-box; overflow-y: auto; /* Allow scrolling on selection screen if needed */ }
        #selection-screen h2 { margin: 15px 0; font-size: clamp(1.5em, 5vw, 2.5em); text-shadow: 2px 2px 5px rgba(0,0,0,0.5); color: #e0e0e0; }
        #beyblade-options { display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; max-width: 800px; padding: 10px; }
        .bey-card { position: relative; width: clamp(280px, 90vw, 350px); height: 150px; min-height: 130px; border-radius: 12px; margin: 5px; cursor: pointer; background-color: #34495e; box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.4); border: 3px solid transparent; transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease; display: flex; flex-direction: column; }
        .bey-card:hover { transform: translateY(-10px) scale(1.03); box-shadow: 8px 12px 20px rgba(0, 0, 0, 0.5); }
        .bey-card .bey-preview { height: 60%; width: 100%; display: flex; justify-content: center; align-items: center; position: relative; }
         .bey-card .bey-symbol { font-size: 3.5em; color: rgba(255, 255, 255, 0.2); text-shadow: 2px 2px 5px rgba(0,0,0,0.4); z-index: 2; }
         .bey-card .bey-info { height: 40%; padding: 10px; box-sizing: border-box; background-color: rgba(0, 0, 0, 0.4); color: #ecf0f1; display: flex; flex-direction: column; justify-content: center; position: relative; z-index: 3; }
          .bey-card .bey-name { font-weight: bold; font-size: 1.1em; margin-bottom: 5px; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); }
          .bey-card .bey-stats { font-size: 0.85em; line-height: 1.3; color: #bdc3c7; }
        .bey-card.selected { border-color: #2ecc71; transform: translateY(-5px) scale(1.05); box-shadow: 0 0 25px rgba(46, 204, 113, 0.7); }
        #start-button { margin-top: 40px; padding: 15px 40px; font-size: 1.6em; cursor: pointer; background: linear-gradient(145deg, #2e60cc, #6d27ae); color: white; border: none; border-radius: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); transition: background 0.2s ease, transform 0.1s ease; display: none; }
        #start-button:hover { background: linear-gradient(145deg, #e33f3f, #2ebb69); }
        #start-button:active { transform: scale(0.97); }
        #start-button:disabled { background: #7f8c8d; cursor: not-allowed; opacity: 0.6; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; cursor: pointer; }
        #game-ui { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); font-size: clamp(1em, 4vw, 1.6em); color: white; background-color: rgba(44, 62, 80, 0.7); padding: 8px 15px; border-radius: 8px; z-index: 6; text-shadow: 1px 1px 3px rgba(0,0,0,0.7); display: none; pointer-events: none; text-align: center; width: 90%; max-width: 500px; margin: 0 auto; }
        #charge-bar-container { position: absolute; bottom: 5%; left: 50%; transform: translateX(-50%); width: clamp(200px, 80%, 350px); height: 30px; background-color: rgba(0, 0, 0, 0.6); border: 2px solid #95a5a6; border-radius: 18px; z-index: 6; display: none; overflow: hidden; pointer-events: none; }
        #charge-bar-fill { width: 100%; height: 100%; background: linear-gradient(to right, #e74c3c, #f39c12, #2ecc71, #f39c12, #e74c3c); border-radius: 16px; }
        #charge-indicator { position: absolute; top: -2px; bottom: -2px; left: 0%; width: 6px; background-color: rgba(255, 255, 255, 0.9); border-radius: 3px; box-shadow: 0 0 5px rgba(255, 255, 255, 0.7); transform: translateX(-50%); transition: left 0.05s linear; }

        /* --- Spin Bar Styles --- */
        .spin-bar-container { position: absolute; top: 100px; width: clamp(120px, 35%, 400px); height: 25px; background-color: rgba(0, 0, 0, 0.5); border: 3px solid #7f8c8d; border-radius: 18px; z-index: 5; overflow: hidden; display: none; /* Initially hidden */ box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .spin-bar-fill { height: 100%; width: 100%; /* Start full */ border-radius: 11px; transition: width 0.15s linear; /* Smooth transition */ background-color: #e67e22; /* Default fill */ }
        .spin-bar-label { color: white; font-size: clamp(0.8em, 3vw, 1.2em); text-shadow: 2px 2px 3px black; position: absolute; top: 50%; transform: translateY(-50%); padding: 0 15px; z-index: 8; pointer-events: none; }

        #player-spin-bar-container { left: 10px; }
        #player-spin-bar-label { left: 0; }
        /* Player fill color set in JS */

        #ai-spin-bar-container { right: 10px; }
        #ai-spin-bar-label { right: 0; text-align: right;}
        /* AI fill color set in JS */
        /* --- End Spin Bar Styles --- */

        /* Media Queries remain the same */
        @media screen and (max-width: 480px) {
            .bey-card { height: 85px; margin: 3px; }
            .bey-card .bey-symbol { font-size: 2.5em; }
            .bey-card .bey-name { font-size: 1em; }
            .bey-card .bey-stats { font-size: 0.75em; }
            #start-button { margin-top: 20px; padding: 10px 30px; font-size: 1.3em; }
        }
        @media screen and (max-width: 360px) {
            .spin-bar-container { height: 20px; }
            .spin-bar-label { padding: 0 8px; }
            #game-ui { padding: 6px 12px; }
        }
        @media screen and (orientation: landscape) and (max-height: 500px) {
            #selection-screen h2 { margin: 10px 0; }
            .bey-card { height: 80px; }
            #start-button { margin-top: 15px; }
            .spin-bar-container { top: 10px; }
            #charge-bar-container { bottom: 3%; }
        }
    </style>
</head>
<body>
    <div id="selection-screen"><h2>Make your choice</h2><div id="beyblade-options"></div><button id="start-button" disabled>Start Game</button></div>

    <div id="game-container">
        {/* Spin Bars */}
        <div id="player-spin-bar-container" class="spin-bar-container">
            <div id="player-spin-bar-fill" class="spin-bar-fill"></div>
            <span id="player-spin-bar-label" class="spin-bar-label">Áé©ÂÆ∂</span>
        </div>
        <div id="ai-spin-bar-container" class="spin-bar-container">
            <div id="ai-spin-bar-fill" class="spin-bar-fill"></div>
             <span id="ai-spin-bar-label" class="spin-bar-label">AI</span>
        </div>
        {/* End Spin Bars */}

        <div id="charge-bar-container"><div id="charge-bar-fill"></div><div id="charge-indicator"></div></div>
    </div>
    <div id="game-ui">Wait for Start...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- Configuration ---
        const BEYBLADE_TYPES = [
             { id: 'pegasus', name: 'Grok', symbol: '‚≠ê', color: 0x4488ff, colorHex: '#3160cb', weight: 1.0, initialSpeed: 0.15, stamina: 120 },
             { id: 'l-drago', name: 'Gemini', symbol: 'üî•', color: 0xff4444, colorHex: '#8b3261', weight: 1.3, initialSpeed: 0.12, stamina: 110 },
             { id: 'libra', name: 'Chat-GPT', symbol: '‚öñÔ∏è', color: 0x44ff44, colorHex: '#438b59', weight: 1.1, initialSpeed: 0.11, stamina: 130 }
        ];

        // --- Arena Size Configuration (MODIFIED) ---
        const ORIGINAL_ARENA_RADIUS = 12;   // Âü∫Ê∫ñÂçäÂæë (‰æãÂ¶ÇÁî®ÊñºÊ°åÈù¢)
        const MIN_ARENA_RADIUS = 8;       // ÊúÄÂ∞èÂçäÂæë (Áî®ÊñºÂ∞èËû¢Âπï)
        const MIN_REF_SCREEN_DIM = 360;   // Ëß∏ÁôºÊúÄÂ∞èÂçäÂæëÁöÑËû¢ÂπïÁü≠ÈÇäÂ∞∫ÂØ∏
        const MAX_REF_SCREEN_DIM = 900;   // ÈÅîÂà∞Âü∫Ê∫ñÂçäÂæëÁöÑËû¢ÂπïÁü≠ÈÇäÂ∞∫ÂØ∏

        const BEYBLADE_RADIUS = 2; // Beyblade radius remains constant

        // -- Physics & Collision Parameters --
        const GRAVITY_TOWARDS_CENTER = 0.0300; const FRICTION = 0.0010; const SPIN_FRICTION = 0.0150;
        const BOUNDARY_ENERGY_LOSS = 0.3; const COLLISION_ENERGY_LOSS = 0.25; const INTENSITY_MULTIPLIER = 1.9;
        const TANGENTIAL_KICK_FACTOR = 30; const COLLISION_SPIN_LOSS_FACTOR = 3.0; const MAX_VELOCITY = 0.6;

        // -- Launch Mechanic Parameters --
        const MIN_LAUNCH_POWER = 0.25; const INDICATOR_SPEED = 4.0;

        // --- Spark Particle Configuration ---
        const SPARK_COUNT = 90;
        const SPARK_LIFESPAN = 0.45;
        const SPARK_SPEED_MIN = 15.0;
        const SPARK_SPEED_MAX = 35.0;
        const SPARK_BASE_SIZE = 5;
        const SPARK_COLOR = 0xff8c00;
        const SPARK_POOL_SIZE = 20;
        const SPARK_GRAVITY = -12.0;

        // --- Global Variables ---
        let scene, camera, renderer;
        let arenaMesh, rimMesh; // Arena floor and rim meshes
        let playerBeyData = { mesh: null, type: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0, maxStamina: 0 };
        let aiBeyData = { mesh: null, type: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0, maxStamina: 0 };
        let gameState = 'selecting';
        let animationFrameId;
        let selectedPlayerTypeId = null;
        let launchInitiated = false;
        let indicatorPosition = 0; let indicatorDirection = 1; let captureIndicatorPosition = -1;
        let sparkPool = []; let sparkPoolIndex = 0; let sparkGeometry = null;
        let sparkTexture = null;
        let initialCameraDir = null; // Store initial viewing direction

        // --- Dynamic Size Variables (NEW) ---
        let arenaRadius = ORIGINAL_ARENA_RADIUS; // Current arena radius, starts at base
        let launchDistance = arenaRadius * 0.65; // Current launch distance

        // --- Materials Cache ---
        const materialsCache = {};
        function getMaterial(color, options = {}) { const key = `${color}_${JSON.stringify(options)}`; if (!materialsCache[key]) { materialsCache[key] = new THREE.MeshStandardMaterial({ color, ...options }); } return materialsCache[key]; }

        // --- DOM Elements ---
        const selectionScreen = document.getElementById('selection-screen'); const beybladeOptionsContainer = document.getElementById('beyblade-options'); const startButton = document.getElementById('start-button'); const gameContainer = document.getElementById('game-container'); const gameUi = document.getElementById('game-ui'); const chargeBarContainer = document.getElementById('charge-bar-container'); const chargeBarFill = document.getElementById('charge-bar-fill'); const chargeIndicator = document.getElementById('charge-indicator');
        const playerSpinBarContainer = document.getElementById('player-spin-bar-container');
        const playerSpinFill = document.getElementById('player-spin-bar-fill');
        const playerSpinLabel = document.getElementById('player-spin-bar-label');
        const aiSpinBarContainer = document.getElementById('ai-spin-bar-container');
        const aiSpinFill = document.getElementById('ai-spin-bar-fill');
        const aiSpinLabel = document.getElementById('ai-spin-bar-label');

        // --- Clock for Delta Time ---
        const clock = new THREE.Clock();

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x231948);
            // Fog will be updated in updateArenaSizeAndDependents

            // Initialize camera - Set initial position based on ORIGINAL size to get direction
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, ORIGINAL_ARENA_RADIUS * 1.5, ORIGINAL_ARENA_RADIUS * 1.1);
            camera.lookAt(0, 0, 0);
            initialCameraDir = camera.position.clone().normalize(); // Store the direction

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            gameContainer.appendChild(renderer.domElement);

            // Lights (Shadow camera bounds might ideally be adjusted too, but omitted for simplicity now)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 20, 15); // Keep light position fixed relative to world
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50;
            // Set initial shadow bounds based on original size, they might need dynamic update if issues arise
            directionalLight.shadow.camera.left = -ORIGINAL_ARENA_RADIUS * 1.5;
            directionalLight.shadow.camera.right = ORIGINAL_ARENA_RADIUS * 1.5;
            directionalLight.shadow.camera.top = ORIGINAL_ARENA_RADIUS * 1.5;
            directionalLight.shadow.camera.bottom = -ORIGINAL_ARENA_RADIUS * 1.5;
            scene.add(directionalLight);
            const fillLight = new THREE.HemisphereLight(0x6060aa, 0x404088, 0.2); scene.add(fillLight);

            // Initialize arena variables before creating geometry
            arenaRadius = ORIGINAL_ARENA_RADIUS;
            launchDistance = arenaRadius * 0.65;

            // Create Arena using the ORIGINAL base size
            createArena(ORIGINAL_ARENA_RADIUS); // Pass the base radius

            initSparkSystem();
            window.addEventListener('resize', onWindowResize, false);
            setupSelectionUI();
            setupLaunchControls();

            // Perform initial size calculation and adjustment
            updateArenaSizeAndDependents(); // NEW: Call this after setup
        }

        // MODIFIED: Accepts radius for building base mesh
        function createArena(radiusToBuild = ORIGINAL_ARENA_RADIUS) {
            // Floor
            const geometry = new THREE.CircleGeometry(radiusToBuild, 64);
            const material = getMaterial(0xff6942, { metalness: 0.3, roughness: 0.6, side: THREE.DoubleSide });
            arenaMesh = new THREE.Mesh(geometry, material);
            arenaMesh.rotation.x = -Math.PI / 2;
            arenaMesh.receiveShadow = true;
            scene.add(arenaMesh);

            // Rim
            const rimGeometry = new THREE.RingGeometry(radiusToBuild, radiusToBuild + 0.6, 64); // Use radiusToBuild
            const rimMaterial = getMaterial(0x454dc4, { metalness: 0.5, roughness: 0.4, side: THREE.DoubleSide });
            rimMesh = new THREE.Mesh(rimGeometry, rimMaterial);
            rimMesh.rotation.x = -Math.PI / 2;
            rimMesh.position.y = 0.02; // Slight offset
            rimMesh.receiveShadow = true;
            scene.add(rimMesh);
        }

        // --- NEW FUNCTION: Update Arena Size ---
        /**
         * Calculates new arena radius based on screen size and updates
         * arena model scale, launch distance, fog, and camera distance.
         */
        function updateArenaSizeAndDependents() {
            // 1. Calculate new arena radius based on the shorter screen dimension
            const currentMinScreenDim = Math.min(window.innerWidth, window.innerHeight);
            const screenRange = MAX_REF_SCREEN_DIM - MIN_REF_SCREEN_DIM;
            const radiusRange = ORIGINAL_ARENA_RADIUS - MIN_ARENA_RADIUS;

            let scaleFactor;
            if (screenRange <= 0) {
                scaleFactor = 1.0; // Avoid division by zero
            } else {
                // Linear interpolation factor based on screen size
                scaleFactor = Math.max(0, Math.min(1, (currentMinScreenDim - MIN_REF_SCREEN_DIM) / screenRange));
            }

            // Calculate the new radius and update the global variable
            const newRadius = MIN_ARENA_RADIUS + radiusRange * scaleFactor;
            arenaRadius = newRadius;

            // 2. Update launch distance based on the new radius
            launchDistance = arenaRadius * 0.65;

            // 3. Update arena model scaling
            const modelScale = arenaRadius / ORIGINAL_ARENA_RADIUS; // Scale relative to original build size
            if (arenaMesh) {
                arenaMesh.scale.set(modelScale, 1, modelScale); // Scale X and Z
            }
            if (rimMesh) {
                rimMesh.scale.set(modelScale, 1, modelScale); // Scale X and Z
            }

            // 4. Update Fog distances
            if (!scene.fog) { // Initialize fog if it doesn't exist yet
                 scene.fog = new THREE.Fog(scene.background, arenaRadius * 2.5, arenaRadius * 5);
            } else { // Update existing fog
                 scene.fog.near = arenaRadius * 2.5;
                 scene.fog.far = arenaRadius * 5;
            }


            // 5. Adjust camera distance to fit the newly sized arena
            adjustCameraToFitArena(); // This function now uses the global `arenaRadius`
        }

        // MODIFIED: Uses global `arenaRadius`
        function adjustCameraToFitArena() {
            if (!camera || !initialCameraDir) return;

            const aspect = camera.aspect;
            const vFovRad = THREE.MathUtils.degToRad(camera.fov);
            const hFovRad = 2 * Math.atan(Math.tan(vFovRad / 2) * aspect);
            const margin = 1.15; // Keep margin
            const targetRadius = arenaRadius * margin; // Use the current global arenaRadius

            const distV = targetRadius / Math.tan(vFovRad / 2);
            const distH = targetRadius / Math.tan(hFovRad / 2);
            const requiredDistance = Math.max(distV, distH);

            // Set position along the original direction, scaled by the required distance
            camera.position.copy(initialCameraDir).multiplyScalar(requiredDistance);
            camera.lookAt(0, 0, 0); // Ensure it still looks at the center
        }

        // --- Other Functions (Modified where necessary) ---

        function initSparkSystem() { /* ... Spark system code remains unchanged ... */
            sparkTexture = createSparkTexture(); // Use the existing radial gradient texture
            sparkGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(SPARK_COUNT * 3); const velocities = new Float32Array(SPARK_COUNT * 3); const startTimes = new Float32Array(SPARK_COUNT); const baseSizes = new Float32Array(SPARK_COUNT);
            sparkGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); sparkGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3)); sparkGeometry.setAttribute('startTime', new THREE.BufferAttribute(startTimes, 1)); sparkGeometry.setAttribute('baseSize', new THREE.BufferAttribute(baseSizes, 1));

            const baseSparkMaterial = new THREE.PointsMaterial({
                size: SPARK_BASE_SIZE, // Use the new larger base size
                color: SPARK_COLOR,    // Use the new orange color
                map: sparkTexture,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false,
                sizeAttenuation: true,
                opacity: 1.0
            });

            for (let i = 0; i < SPARK_POOL_SIZE; i++) {
                const materialClone = baseSparkMaterial.clone();
                const points = new THREE.Points(sparkGeometry, materialClone);
                points.visible = false;
                points.userData = { isActive: false, activationTime: 0 };
                sparkPool.push(points);
                scene.add(points);
            }
        }

        function createSparkTexture() { /* ... Spark texture code remains unchanged ... */
             const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64; const context = canvas.getContext('2d'); const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32); gradient.addColorStop(0, 'rgba(255, 255, 220, 1)'); gradient.addColorStop(0.1, 'rgba(255, 200, 100, 1)'); gradient.addColorStop(0.4, 'rgba(255, 165, 0, 0.6)'); gradient.addColorStop(1, 'rgba(255, 140, 0, 0)'); context.fillStyle = gradient; context.fillRect(0, 0, 64, 64); const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; return texture;
        }

        function setupSelectionUI() { /* ... Selection UI code remains unchanged ... */
             beybladeOptionsContainer.innerHTML = ''; if (!beybladeOptionsContainer) { console.error("Element with ID 'beyblade-options' not found!"); return; } BEYBLADE_TYPES.forEach(type => { const card = document.createElement('div'); card.classList.add('bey-card'); card.dataset.beyId = type.id; const previewArea = document.createElement('div'); previewArea.classList.add('bey-preview'); previewArea.style.background = `radial-gradient(ellipse at top, ${lightenColor(type.colorHex, 30)}, ${type.colorHex} 70%)`; const symbolSpan = document.createElement('span'); symbolSpan.classList.add('bey-symbol'); symbolSpan.textContent = type.symbol || 'üåÄ'; previewArea.appendChild(symbolSpan); card.appendChild(previewArea); const infoDiv = document.createElement('div'); infoDiv.classList.add('bey-info'); infoDiv.innerHTML = `<div class="bey-name">${type.name}</div><div class="bey-stats">È´îÈáç: ${type.weight.toFixed(1)} | ÈÄüÂ∫¶: ${type.initialSpeed.toFixed(2)} | ËÄêÂäõ: ${type.stamina}</div>`; card.appendChild(infoDiv); card.addEventListener('click', () => { document.querySelectorAll('.bey-card').forEach(c => c.classList.remove('selected')); card.classList.add('selected'); selectedPlayerTypeId = type.id; if(startButton) { startButton.disabled = false; startButton.style.display = 'inline-block'; } }); beybladeOptionsContainer.appendChild(card); }); if(startButton) startButton.addEventListener('click', startGame);
        }

        function lightenColor(hex, percent) { /* ... lightenColor code remains unchanged ... */
              hex = hex.replace(/^#/, ''); const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); const newR = Math.min(255, r + Math.floor(255 * (percent / 100))); const newG = Math.min(255, g + Math.floor(255 * (percent / 100))); const newB = Math.min(255, b + Math.floor(255 * (percent / 100))); return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }

        function startGame() { /* ... startGame logic largely unchanged ... */
             if (!selectedPlayerTypeId) return;
             gameState = 'preparing';
             launchInitiated = false;
             captureIndicatorPosition = -1;
             indicatorPosition = Math.random();
             indicatorDirection = Math.random() < 0.5 ? 1 : -1;

             selectionScreen.style.display = 'none';
             gameContainer.style.display = 'block';
             gameUi.style.display = 'block';
             gameUi.textContent = "Ê∫ñÂÇô...";

             playerBeyData.type = BEYBLADE_TYPES.find(b => b.id === selectedPlayerTypeId);
             const availableAiTypes = BEYBLADE_TYPES.filter(b => b.id !== selectedPlayerTypeId);
             aiBeyData.type = availableAiTypes[Math.floor(Math.random() * availableAiTypes.length)];

             playerBeyData.maxStamina = playerBeyData.type.stamina;
             aiBeyData.maxStamina = aiBeyData.type.stamina;

             resetBattle();
             setupBattle(); // Uses the current launchDistance

             // Show Spin Bars etc.
             if (playerSpinBarContainer) playerSpinBarContainer.style.display = 'block';
             if (aiSpinBarContainer) aiSpinBarContainer.style.display = 'block';
             if (playerSpinFill) { playerSpinFill.style.width = '100%'; playerSpinFill.style.backgroundColor = playerBeyData.type.colorHex; playerSpinLabel.textContent = playerBeyData.type.name; }
             if (aiSpinFill) { aiSpinFill.style.width = '100%'; aiSpinFill.style.backgroundColor = aiBeyData.type.colorHex; aiSpinLabel.textContent = aiBeyData.type.name; }

             setTimeout(() => {
                 gameState = 'launching';
                 if(chargeBarContainer) chargeBarContainer.style.display = 'block';
                 if(chargeIndicator) chargeIndicator.style.left = `${indicatorPosition * 100}%`;
                 gameUi.textContent = "ÈªûÊìäËìÑÂäõ!";
                 if (!animationFrameId) { animate(); }
             }, 500);
        }

        function setupLaunchControls() { /* ... Launch controls unchanged ... */
              if(gameContainer) gameContainer.addEventListener('pointerdown', captureLaunchTiming);
        }

        function captureLaunchTiming(event) { /* ... Capture timing unchanged ... */
             if (gameState === 'launching' && !launchInitiated) { event.preventDefault(); captureIndicatorPosition = indicatorPosition; initiateLaunch(); }
        }

        // MODIFIED: Uses global `launchDistance`
        function initiateLaunch() {
              if (launchInitiated || captureIndicatorPosition < 0) return;
              launchInitiated = true;
              if(chargeBarContainer) chargeBarContainer.style.display = 'none';

              const deviation = Math.abs(captureIndicatorPosition - 0.5);
              const timedPower = 1.0 - deviation * 2;
              const launchPowerFactor = MIN_LAUNCH_POWER + timedPower * (1.0 - MIN_LAUNCH_POWER);
              playerBeyData.angularVelocity = playerBeyData.maxStamina * launchPowerFactor;

              const aiLaunchPowerFactor = MIN_LAUNCH_POWER + Math.random() * (1.0 - MIN_LAUNCH_POWER);
              aiBeyData.angularVelocity = aiBeyData.maxStamina * aiLaunchPowerFactor;

              // Set initial linear velocities using current launchDistance
              playerBeyData.velocity.set(launchDistance * 0.8, 0, (Math.random() - 0.5) * launchDistance * 0.8).normalize().multiplyScalar(playerBeyData.type.initialSpeed * (0.8 + launchPowerFactor * 0.4));
              aiBeyData.velocity.set(-launchDistance * 0.8, 0, (Math.random() - 0.5) * launchDistance * 0.8).normalize().multiplyScalar(aiBeyData.type.initialSpeed * (0.8 + aiLaunchPowerFactor * 0.4));

              gameUi.textContent = "Battle Start!";
              setTimeout(() => { if (gameState === 'launching') gameState = 'fighting'; }, 100);
        }

        function resetBattle() { /* ... resetBattle unchanged ... */
             if (playerBeyData.mesh) scene.remove(playerBeyData.mesh);
             if (aiBeyData.mesh) scene.remove(aiBeyData.mesh);
             playerBeyData = { ...playerBeyData, mesh: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0 };
             aiBeyData = { ...aiBeyData, mesh: null, velocity: new THREE.Vector3(), angularVelocity: 0, isOut: false, baseOffset: 0 };

             sparkPool.forEach(points => {
                 if (points.userData.isActive) {
                     points.visible = false; points.userData.isActive = false;
                     points.material.opacity = 1.0; points.material.size = SPARK_BASE_SIZE;
                 }
             });
             sparkPoolIndex = 0;

             if (playerSpinBarContainer) playerSpinBarContainer.style.display = 'none';
             if (aiSpinBarContainer) aiSpinBarContainer.style.display = 'none';
        }

        function createBeybladeMesh(beyType) { /* ... createBeybladeMesh unchanged ... */
            const group = new THREE.Group();
            const radius = BEYBLADE_RADIUS; // Use the constant Beyblade radius
            const mainHeight = radius * 0.6;
            const detailHeight = radius * 0.4;
            const mainMat = getMaterial(beyType.color, { metalness: 0.5, roughness: 0.4 });
            const metalMat = getMaterial(0xcccccc, { metalness: 0.8, roughness: 0.3 });
            const darkMetalMat = getMaterial(0x555555, { metalness: 0.7, roughness: 0.4 });
            const accentMat = getMaterial(0xffff00, { metalness: 0.6, roughness: 0.4 });
            let lowestY = 0;

            switch (beyType.id) { /* ... cases remain the same ... */
                case 'pegasus': {
                    const bodyGeo = new THREE.CylinderGeometry(radius * 0.8, radius * 0.5, mainHeight, 16);
                    const bodyMesh = new THREE.Mesh(bodyGeo, mainMat);
                    bodyMesh.position.y = detailHeight + mainHeight / 2; bodyMesh.castShadow = true; group.add(bodyMesh);
                    const ringGeo = new THREE.TorusGeometry(radius * 0.9, radius * 0.15, 8, 32);
                    const ringMesh = new THREE.Mesh(ringGeo, metalMat);
                    ringMesh.rotation.x = Math.PI / 2; ringMesh.position.y = detailHeight * 0.8; ringMesh.castShadow = true; group.add(ringMesh);
                    const baseGeo = new THREE.ConeGeometry(radius * 0.6, detailHeight, 16);
                    const baseMesh = new THREE.Mesh(baseGeo, metalMat);
                    baseMesh.position.y = detailHeight / 2; baseMesh.castShadow = true; group.add(baseMesh);
                    lowestY = 0; break;
                }
                case 'l-drago': {
                    const bodyGeo = new THREE.ConeGeometry(radius * 0.7, mainHeight * 1.2, 16);
                    const bodyMesh = new THREE.Mesh(bodyGeo, mainMat);
                    bodyMesh.position.y = detailHeight + mainHeight * 0.6; bodyMesh.castShadow = true; group.add(bodyMesh);
                    const wheelGeo = new THREE.CylinderGeometry(radius * 1.0, radius * 0.9, detailHeight * 0.8, 16);
                    const wheelMesh = new THREE.Mesh(wheelGeo, darkMetalMat);
                    wheelMesh.position.y = detailHeight * 0.6; wheelMesh.castShadow = true; group.add(wheelMesh);
                    const baseGeo = new THREE.CylinderGeometry(radius * 0.4, radius * 0.2, detailHeight * 0.4, 16);
                    const baseMesh = new THREE.Mesh(baseGeo, darkMetalMat);
                    baseMesh.position.y = detailHeight * 0.2; baseMesh.castShadow = true; group.add(baseMesh);
                    lowestY = 0; break;
                }
                case 'libra': default: {
                    const bodyGeo = new THREE.CylinderGeometry(radius * 0.95, radius * 0.85, mainHeight * 0.6, 24);
                    const bodyMesh = new THREE.Mesh(bodyGeo, mainMat);
                    bodyMesh.position.y = detailHeight + (mainHeight * 0.6) / 2; bodyMesh.castShadow = true; group.add(bodyMesh);
                    const ringGeo = new THREE.TorusGeometry(radius * 0.8, radius * 0.18, 8, 32);
                    const ringMesh = new THREE.Mesh(ringGeo, metalMat);
                    ringMesh.rotation.x = Math.PI / 2; ringMesh.position.y = detailHeight * 0.7; ringMesh.castShadow = true; group.add(ringMesh);
                    const baseTopGeo = new THREE.CylinderGeometry(radius * 0.6, radius * 0.7, detailHeight * 0.4, 16);
                    const baseTopMesh = new THREE.Mesh(baseTopGeo, accentMat);
                    baseTopMesh.position.y = detailHeight * 0.6; baseTopMesh.castShadow = true; group.add(baseTopMesh);
                    const baseBottomGeo = new THREE.CylinderGeometry(radius * 0.7, radius * 0.5, detailHeight * 0.4, 16);
                    const baseBottomMesh = new THREE.Mesh(baseBottomGeo, accentMat);
                    baseBottomMesh.position.y = detailHeight * 0.2; baseBottomMesh.castShadow = true; group.add(baseBottomMesh);
                    lowestY = 0; break;
                }
            }
            group.position.y = -lowestY;
            const meshBaseOffset = -lowestY;
            return { mesh: group, baseOffset: meshBaseOffset };
        }

        // MODIFIED: Uses global `launchDistance`
        function setupBattle() {
            const playerResult = createBeybladeMesh(playerBeyData.type);
            playerBeyData.mesh = playerResult.mesh;
            playerBeyData.baseOffset = playerResult.baseOffset;
            // Use current launchDistance for positioning
            playerBeyData.mesh.position.set(-launchDistance, playerBeyData.baseOffset, (Math.random() - 0.5) * 4);
            scene.add(playerBeyData.mesh);

            const aiResult = createBeybladeMesh(aiBeyData.type);
            aiBeyData.mesh = aiResult.mesh;
            aiBeyData.baseOffset = aiResult.baseOffset;
            // Use current launchDistance for positioning
            aiBeyData.mesh.position.set(launchDistance, aiBeyData.baseOffset, (Math.random() - 0.5) * 4);
            scene.add(aiBeyData.mesh);
        }

        function triggerSparks(position, intensity) { /* ... triggerSparks unchanged ... */
            const points = sparkPool[sparkPoolIndex]; if (!points) return; const geometry = points.geometry; const attributes = geometry.attributes; if (!attributes.velocity || !attributes.startTime || !attributes.position || !attributes.baseSize) { console.error("Spark geometry attributes missing!"); return; } const velocities = attributes.velocity.array; const startTimes = attributes.startTime.array; const positions = attributes.position.array; const baseSizes = attributes.baseSize.array; points.position.copy(position); const currentTime = clock.elapsedTime; const intensityFactor = Math.min(1, Math.sqrt(intensity / 20)); const speedRange = SPARK_SPEED_MAX - SPARK_SPEED_MIN; for (let i = 0; i < SPARK_COUNT; i++) { const i3 = i * 3; const angle = Math.random() * Math.PI * 2; const heightFactor = Math.random() * 2 - 1; const radius = Math.random(); const dirX = Math.cos(angle) * radius; const dirY = Math.abs(heightFactor) + 0.2; const dirZ = Math.sin(angle) * radius; const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ); const speed = SPARK_SPEED_MIN + Math.random() * speedRange * intensityFactor; velocities[i3 + 0] = (dirX / length) * speed * (1 + Math.random() * 0.5); velocities[i3 + 1] = (dirY / length) * speed * (1 + Math.random() * 0.5); velocities[i3 + 2] = (dirZ / length) * speed * (1 + Math.random() * 0.5); positions[i3 + 0] = 0; positions[i3 + 1] = 0; positions[i3 + 2] = 0; startTimes[i] = currentTime; baseSizes[i] = SPARK_BASE_SIZE * (0.5 + Math.random()); } attributes.position.needsUpdate = true; attributes.velocity.needsUpdate = true; attributes.startTime.needsUpdate = true; attributes.baseSize.needsUpdate = true; points.material.opacity = 1.0; points.visible = true; points.userData.isActive = true; points.userData.activationTime = currentTime; sparkPoolIndex = (sparkPoolIndex + 1) % SPARK_POOL_SIZE;
        }

        // --- Game Loop ---
        function animate() { /* ... animate loop structure remains the same ... */
            animationFrameId = requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const currentTime = clock.elapsedTime;

            // --- Indicator Movement ---
            if (gameState === 'launching' && !launchInitiated) { /* ... indicator logic unchanged ... */
                indicatorPosition += indicatorDirection * INDICATOR_SPEED * delta;
                if (indicatorPosition >= 1.0) { indicatorPosition = 1.0; indicatorDirection = -1; }
                else if (indicatorPosition <= 0.0) { indicatorPosition = 0.0; indicatorDirection = 1; }
                if (chargeIndicator) { chargeIndicator.style.left = `${indicatorPosition * 100}%`; }
            }

            // --- Main Game Logic ---
            if (gameState === 'fighting') {
                updatePhysics(playerBeyData, delta); // Physics uses global arenaRadius
                updatePhysics(aiBeyData, delta);
                handleCollisions(delta);
                checkWinConditions();

                // --- Update Spin Bars --- (unchanged)
                const playerSpinPercent = Math.max(0, Math.min(100, (playerBeyData.angularVelocity / playerBeyData.maxStamina) * 100));
                const aiSpinPercent = Math.max(0, Math.min(100, (aiBeyData.angularVelocity / aiBeyData.maxStamina) * 100));
                if (playerSpinFill) playerSpinFill.style.width = playerSpinPercent + '%';
                if (aiSpinFill) aiSpinFill.style.width = aiSpinPercent + '%';
            }

            // --- Spark Update --- (unchanged)
            sparkPool.forEach(points => { /* ... spark update logic unchanged ... */
                if (points.userData.isActive) { const activationTime = points.userData.activationTime; const elapsedTime = currentTime - activationTime; const lifeRatio = Math.min(1.0, elapsedTime / SPARK_LIFESPAN); if (lifeRatio >= 1.0) { points.visible = false; points.userData.isActive = false; } else { points.material.opacity = Math.pow(1.0 - lifeRatio, 1.5); points.material.size = SPARK_BASE_SIZE * (1.0 - lifeRatio * 0.8); const geometry = points.geometry; const attributes = geometry.attributes; const positions = attributes.position.array; const velocities = attributes.velocity.array; const startTimes = attributes.startTime.array; let needsPosUpdate = false; for (let i = 0; i < SPARK_COUNT; i++) { if (startTimes[i] === activationTime) { const i3 = i * 3; const particleElapsedTime = currentTime - startTimes[i]; positions[i3 + 0] = velocities[i3 + 0] * particleElapsedTime; positions[i3 + 1] = velocities[i3 + 1] * particleElapsedTime + 0.5 * SPARK_GRAVITY * particleElapsedTime * particleElapsedTime; positions[i3 + 2] = velocities[i3 + 2] * particleElapsedTime; needsPosUpdate = true; } } if(needsPosUpdate) { attributes.position.needsUpdate = true; } } } });
            // --- End Spark Update ---

            renderer.render(scene, camera);
        }

        // --- Physics & Logic ---
        // MODIFIED: Uses global `arenaRadius` for boundary checks
        function updatePhysics(beyData, delta) {
            const groundY = beyData.baseOffset;
            if (!beyData.mesh || beyData.isOut || beyData.angularVelocity <= 0) { /* ... handling stopped/out beys unchanged ... */
                if (beyData.angularVelocity <= 0 && !beyData.isOut && beyData.mesh) { beyData.velocity.set(0, 0, 0); if (beyData.mesh.position.y !== groundY) beyData.mesh.position.y = groundY; } return;
            }

            const mesh = beyData.mesh; const velocity = beyData.velocity; const type = beyData.type;
            const frictionFactor = Math.pow(1.0 - FRICTION, delta * 60);
            velocity.multiplyScalar(frictionFactor);

            const spinDrainMultiplier = Math.max(0.6, (2.2 - type.stamina / 100));
            beyData.angularVelocity -= SPIN_FRICTION * spinDrainMultiplier * delta * 60;
            beyData.angularVelocity = Math.max(0, beyData.angularVelocity);

            // Gravity towards center (unchanged logic)
            if (GRAVITY_TOWARDS_CENTER > 0) { /* ... gravity logic unchanged ... */
                const centerPull = mesh.position.clone().setY(0).negate(); const distFromCenter = centerPull.length(); const randomAngle = Math.random() * Math.PI * 2; const randomOffset = new THREE.Vector3(Math.cos(randomAngle), 0, Math.sin(randomAngle)); const centerInfluence = Math.min(1.0, distFromCenter / (arenaRadius * 0.8)); const randomInfluence = 1 - centerInfluence; centerPull.normalize(); const finalDirection = centerPull.multiplyScalar(centerInfluence).add(randomOffset.multiplyScalar(randomInfluence)).normalize(); const pullStrength = GRAVITY_TOWARDS_CENTER * (0.8 + Math.random() * 0.4); velocity.add(finalDirection.multiplyScalar(pullStrength * delta * 60 / type.weight));
            }

            mesh.position.addScaledVector(velocity, delta * 60);
            mesh.rotation.y += beyData.angularVelocity * 0.1 * delta * 60;

            // Boundary collision using current arenaRadius
            const distanceFromCenter = mesh.position.clone().setY(0).length();
            // ---> USE arenaRadius HERE <---
            if (distanceFromCenter > arenaRadius - BEYBLADE_RADIUS) {
                const normal = mesh.position.clone().setY(0).normalize().negate();
                const velocityBeforeBounce = velocity.clone();

                const deflectionAngle = (Math.random() - 0.5) * Math.PI * 0.6;
                normal.applyAxisAngle(new THREE.Vector3(0, 1, 0), deflectionAngle);
                velocity.reflect(normal);

                const energyLoss = BOUNDARY_ENERGY_LOSS * (0.8 + Math.random() * 0.4);
                velocity.multiplyScalar(1.0 - energyLoss);

                // ---> USE arenaRadius HERE <--- for spark position
                const sparkPosition = mesh.position.clone().setY(0).setLength(arenaRadius - BEYBLADE_RADIUS * 0.5);
                sparkPosition.y = beyData.baseOffset + BEYBLADE_RADIUS * 0.3;
                const impactSpeed = velocityBeforeBounce.dot(normal.clone().negate());
                const sparkIntensity = Math.abs(impactSpeed) * 35 + 10;
                triggerSparks(sparkPosition, sparkIntensity);

                const correctionDir = mesh.position.clone().setY(0).normalize();
                // ---> USE arenaRadius HERE <--- for correction
                const correctedRadiusPos = (arenaRadius - BEYBLADE_RADIUS - 0.01) * (0.99 + Math.random() * 0.02);
                mesh.position.x = correctionDir.x * correctedRadiusPos;
                mesh.position.z = correctionDir.z * correctedRadiusPos;

                if (velocity.dot(correctionDir) > 0) { velocity.projectOnVector(normal); }
            }

            mesh.position.y = groundY; // Ensure Bey stays on the ground plane
        }

        function handleCollisions(delta) { /* ... Collision logic remains unchanged ... */
            if (!playerBeyData.mesh || !aiBeyData.mesh || playerBeyData.isOut || aiBeyData.isOut || gameState !== 'fighting') return; const playerGroundY = playerBeyData.baseOffset; const aiGroundY = aiBeyData.baseOffset; const pos1 = playerBeyData.mesh.position; const pos2 = aiBeyData.mesh.position; const pos1_xz = new THREE.Vector2(pos1.x, pos1.z); const pos2_xz = new THREE.Vector2(pos2.x, pos2.z); const distSq = pos1_xz.distanceToSquared(pos2_xz); const combinedRadius = BEYBLADE_RADIUS * 2; if (distSq < combinedRadius * combinedRadius && distSq > 0.0001) { const v1 = playerBeyData.velocity; const v2 = aiBeyData.velocity; const m1 = playerBeyData.type.weight; const m2 = aiBeyData.type.weight; const collisionNormal = pos1.clone().sub(pos2).setY(0).normalize(); const relativeVelocity = v1.clone().sub(v2); const velAlongNormal = relativeVelocity.dot(collisionNormal); if (velAlongNormal > 0) return; const restitution = 1.0 - COLLISION_ENERGY_LOSS; let j = -(1 + restitution) * velAlongNormal; j /= (1 / m1) + (1 / m2); j *= INTENSITY_MULTIPLIER; const collisionIntensity = Math.abs(j) * 1.0 + 5; const sparkPos1 = pos1.clone(); sparkPos1.y += BEYBLADE_RADIUS * 0.2; triggerSparks(sparkPos1, collisionIntensity); const sparkPos2 = pos2.clone(); sparkPos2.y += BEYBLADE_RADIUS * 0.2; triggerSparks(sparkPos2, collisionIntensity); if (TANGENTIAL_KICK_FACTOR > 0) { let tangent = new THREE.Vector3(-collisionNormal.z, 0, collisionNormal.x).normalize(); const spinDiff = playerBeyData.angularVelocity - aiBeyData.angularVelocity; if (spinDiff > 0) { tangent.multiplyScalar(1); } else { tangent.multiplyScalar(-1); } const randomAngle = (Math.random() - 0.5) * Math.PI * 0.5; tangent.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle); const spinFactor = Math.abs(spinDiff) / Math.max(playerBeyData.maxStamina, aiBeyData.maxStamina); const tangentialImpulseMagnitude = Math.abs(j) * TANGENTIAL_KICK_FACTOR * (1 + spinFactor); const tangentialImpulse = tangent.multiplyScalar(tangentialImpulseMagnitude); v1.add(tangentialImpulse.clone().multiplyScalar(1 / m1)); v2.sub(tangentialImpulse.clone().multiplyScalar(1 / m2)); } if (COLLISION_SPIN_LOSS_FACTOR > 0) { const spinLossMagnitude = Math.abs(j) * COLLISION_SPIN_LOSS_FACTOR; playerBeyData.angularVelocity = Math.max(0, playerBeyData.angularVelocity - spinLossMagnitude / m1); aiBeyData.angularVelocity = Math.max(0, aiBeyData.angularVelocity - spinLossMagnitude / m2); } const impulse = collisionNormal.clone().multiplyScalar(j); v1.add(impulse.clone().multiplyScalar(1 / m1)); v2.sub(impulse.clone().multiplyScalar(1 / m2)); if (v1.length() > MAX_VELOCITY) v1.setLength(MAX_VELOCITY); if (v2.length() > MAX_VELOCITY) v2.setLength(MAX_VELOCITY); const overlap = combinedRadius - Math.sqrt(distSq); if (overlap > 0) { const separationNormal = pos1.clone().sub(pos2).setY(0).normalize(); const correctionScale = Math.max(0.51, Math.min(0.8, overlap * 0.5)); const correction = separationNormal.multiplyScalar(overlap * correctionScale); pos1.add(correction); pos2.sub(correction); pos1.y = playerGroundY; pos2.y = aiGroundY; } }
        }

        function checkWinConditions() { /* ... checkWinConditions unchanged ... */
            let winner = null; let loser = null; let reason = ""; if (playerBeyData.isOut && !aiBeyData.isOut) { winner = aiBeyData.type.name; loser = playerBeyData.type.name; reason = "Ë¢´ÊâìÂá∫Áïå"; } else if (aiBeyData.isOut && !playerBeyData.isOut) { winner = playerBeyData.type.name; loser = aiBeyData.type.name; reason = "Ë¢´ÊâìÂá∫Áïå"; } const playerSpinning = playerBeyData.angularVelocity > 0 && !playerBeyData.isOut; const aiSpinning = aiBeyData.angularVelocity > 0 && !aiBeyData.isOut; if (!winner) { if (!playerSpinning && aiSpinning) { winner = aiBeyData.type.name; loser = playerBeyData.type.name; reason = "ÂÅúÊ≠¢ÊóãËΩâ"; } else if (!aiSpinning && playerSpinning) { winner = playerBeyData.type.name; loser = aiBeyData.type.name; reason = "ÂÅúÊ≠¢ÊóãËΩâ"; } else if (!playerSpinning && !aiSpinning && !playerBeyData.isOut && !aiBeyData.isOut) { winner = "Âπ≥Êâã"; reason = "ÈõôÊñπÂÅúÊ≠¢ÊóãËΩâ"; } } if (playerBeyData.isOut && aiBeyData.isOut) { winner = "Âπ≥Êâã"; reason = "ÈõôÊñπÈÉΩË¢´ÊâìÂá∫Áïå"; } if (winner && (gameState === 'fighting' || gameState === 'launching')) { endGame(winner, loser, reason); }
        }

        function endGame(winner, loser, reason) { /* ... endGame unchanged ... */
             if (gameState === 'gameOver') return;
             gameState = 'gameOver';
             if(chargeBarContainer) chargeBarContainer.style.display = 'none';
             let message = ""; if (winner === "Âπ≥Êâã") { message = `Âπ≥Êâã! (${reason})`; } else { if (winner === playerBeyData.type.name) { message = `ÊÅ≠Âñú ${playerBeyData.type.name} Áç≤Âãù! (AI ${loser} ${reason})`; } else { message = `‰Ω†Ëº∏‰∫Ü! AI ${aiBeyData.type.name} Áç≤Âãù! (${playerBeyData.type.name} ${reason})`; } } gameUi.textContent = message; gameUi.style.display = 'block';
             setTimeout(() => {
                 if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                 selectedPlayerTypeId = null; document.querySelectorAll('.bey-card').forEach(c => c.classList.remove('selected'));
                 if(startButton) { startButton.disabled = true; startButton.style.display = 'none'; }
                 selectionScreen.style.display = 'flex'; gameContainer.style.display = 'none'; gameUi.style.display = 'none';
                 resetBattle();
             }, 4000);
        }

        // MODIFIED: Calls updateArenaSizeAndDependents
        function onWindowResize() {
            if (!camera || !renderer) return; // Add safety check

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); // Update projection first
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Update arena size and camera position
            updateArenaSizeAndDependents(); // Recalculate and adjust everything
        }

        // --- Start ---
        init();
    </script>

</body>
</html>
